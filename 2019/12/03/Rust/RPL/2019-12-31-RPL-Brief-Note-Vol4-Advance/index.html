<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  
  
  <meta name="description" content="AI | NLP | 人工智能 | 哲学 | 自然语言处理 | 机器学习">
  

  
  
  
  
  
  <title>The Rust Programming Language Brief Note (Vol4-Advance) | Yam</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="15 Smart Pointers15-1 Using Box to Point to Data on the Heap15-1-1 Using a Box&amp;lt;T&amp;gt; to Store Data on the Heap15-1-2 Enabling Recursive Types with Boxes15-1-2-1 More Information About the Cons List">
<meta name="keywords" content="Rust">
<meta property="og:type" content="article">
<meta property="og:title" content="The Rust Programming Language Brief Note (Vol4-Advance)">
<meta property="og:url" content="https://yam.gift/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance/index.html">
<meta property="og:site_name" content="Yam">
<meta property="og:description" content="15 Smart Pointers15-1 Using Box to Point to Data on the Heap15-1-1 Using a Box&amp;lt;T&amp;gt; to Store Data on the Heap15-1-2 Enabling Recursive Types with Boxes15-1-2-1 More Information About the Cons List">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://doc.rust-lang.org/stable/book/img/trpl15-02.svg">
<meta property="og:image" content="https://doc.rust-lang.org/stable/book/img/trpl15-03.svg">
<meta property="og:image" content="https://doc.rust-lang.org/stable/book/img/trpl15-04.svg">
<meta property="og:updated_time" content="2024-06-12T02:06:43.551Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="The Rust Programming Language Brief Note (Vol4-Advance)">
<meta name="twitter:description" content="15 Smart Pointers15-1 Using Box to Point to Data on the Heap15-1-1 Using a Box&amp;lt;T&amp;gt; to Store Data on the Heap15-1-2 Enabling Recursive Types with Boxes15-1-2-1 More Information About the Cons List">
<meta name="twitter:image" content="https://doc.rust-lang.org/stable/book/img/trpl15-02.svg">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
<link rel="alternate" href="/atom.xml" title="Yam" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /><!-- hexo-inject:begin --><!-- hexo-inject:end --></head></html>
<body class="home blog custom-background custom-font-enabled single-author">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="Yam" rel="home">Yam</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">Feeling, Coding, Thinking</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/series/">Series</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives/">Archives</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/about/">About</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="https://github.com/hscspring">Projects</a></li>
                
                </ul>
            </div>
    </nav>
</header>
      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance" class="post-Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      The Rust Programming Language Brief Note (Vol4-Advance)
    </h1>
  

        
        <!-- <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="https://yam.gift/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance/" data-id="cm5jp90qz01lfvmbz6hcvaxrv" class="leave-reply bdsharebuttonbox" data-cmd="more"></a>
        </div> --><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
            <!-- Table of Contents -->
              
        <div class="toc"><ul class="toc-item"><li><span><a href="#15-Smart-Pointers" data-toc-modified-id="15-Smart-Pointers-1">15 Smart Pointers</a></span><ul class="toc-item"><li><span><a href="#15-1-Using-Box-to-Point-to-Data-on-the-Heap" data-toc-modified-id="15-1-Using-Box-to-Point-to-Data-on-the-Heap-1.1">15-1 Using Box to Point to Data on the Heap</a></span><ul class="toc-item"><li><span><a href="#15-1-1-Using-a-Box<T>-to-Store-Data-on-the-Heap" data-toc-modified-id="15-1-1-Using-a-Box<T>-to-Store-Data-on-the-Heap-1.1.1">15-1-1 Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</a></span></li><li><span><a href="#15-1-2-Enabling-Recursive-Types-with-Boxes" data-toc-modified-id="15-1-2-Enabling-Recursive-Types-with-Boxes-1.1.2">15-1-2 Enabling Recursive Types with Boxes</a></span><ul class="toc-item"><li><span><a href="#15-1-2-1-More-Information-About-the-Cons-List" data-toc-modified-id="15-1-2-1-More-Information-About-the-Cons-List-1.1.2.1">15-1-2-1 More Information About the Cons List</a></span></li><li><span><a href="#15-1-2-2-Computing-the-Size-of-a-Non-Recursive-Type" data-toc-modified-id="15-1-2-2-Computing-the-Size-of-a-Non-Recursive-Type-1.1.2.2">15-1-2-2 Computing the Size of a Non-Recursive Type</a></span></li><li><span><a href="#15-1-2-3-Using-Box<T>-to-Get-a-Recursive-Type-with-a-Known-Size" data-toc-modified-id="15-1-2-3-Using-Box<T>-to-Get-a-Recursive-Type-with-a-Known-Size-1.1.2.3">15-1-2-3 Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</a></span></li></ul></li></ul></li><li><span><a href="#15-2-Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait" data-toc-modified-id="15-2-Treating-Smart-Pointers-Like-Regular-References-with-the-Deref-Trait-1.2">15-2 Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></span><ul class="toc-item"><li><span><a href="#15-2-1-Following-the-Pointer-to-the-Value-with-the-Dereference-Operator" data-toc-modified-id="15-2-1-Following-the-Pointer-to-the-Value-with-the-Dereference-Operator-1.2.1">15-2-1 Following the Pointer to the Value with the Dereference Operator</a></span></li><li><span><a href="#15-2-2-Using-Box<T>-Like-a-Reference" data-toc-modified-id="15-2-2-Using-Box<T>-Like-a-Reference-1.2.2">15-2-2 Using <code>Box&lt;T&gt;</code> Like a Reference</a></span></li><li><span><a href="#15-2-3-Defining-Our-Own-Smart-Pointer" data-toc-modified-id="15-2-3-Defining-Our-Own-Smart-Pointer-1.2.3">15-2-3 Defining Our Own Smart Pointer</a></span></li><li><span><a href="#15-2-4-Treating-a-Type-Like-a-Reference-by-Implementing-the-Deref-Trait" data-toc-modified-id="15-2-4-Treating-a-Type-Like-a-Reference-by-Implementing-the-Deref-Trait-1.2.4">15-2-4 Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</a></span></li><li><span><a href="#15-2-5-Implicit-Deref-Coercions-with-Functions-and-Methods" data-toc-modified-id="15-2-5-Implicit-Deref-Coercions-with-Functions-and-Methods-1.2.5">15-2-5 Implicit Deref Coercions with Functions and Methods</a></span></li><li><span><a href="#15-2-6-How-Deref-Coercion-Interacts-with-Mutability" data-toc-modified-id="15-2-6-How-Deref-Coercion-Interacts-with-Mutability-1.2.6">15-2-6 How Deref Coercion Interacts with Mutability</a></span></li></ul></li><li><span><a href="#15-3-Running-Code-on-Cleanup-with-the-Drop-Trait" data-toc-modified-id="15-3-Running-Code-on-Cleanup-with-the-Drop-Trait-1.3">15-3 Running Code on Cleanup with the <code>Drop</code> Trait</a></span><ul class="toc-item"><li><span><a href="#15-3-1-Dropping-a-Value-Early-with-std::mem::drop" data-toc-modified-id="15-3-1-Dropping-a-Value-Early-with-std::mem::drop-1.3.1">15-3-1 Dropping a Value Early with <code>std::mem::drop</code></a></span></li></ul></li><li><span><a href="#15-4-Rc<T>-the-Reference-Counted-Smart-Pointer" data-toc-modified-id="15-4-Rc<T>-the-Reference-Counted-Smart-Pointer-1.4">15-4 <code>Rc&lt;T&gt;</code> the Reference Counted Smart Pointer</a></span><ul class="toc-item"><li><span><a href="#15-4-1-Using-Rc<T>-to-Share-Data" data-toc-modified-id="15-4-1-Using-Rc<T>-to-Share-Data-1.4.1">15-4-1 Using <code>Rc&lt;T&gt;</code> to Share Data</a></span></li><li><span><a href="#15-4-2-Cloning-an-Rc<T>-Increases-the-Reference-Count" data-toc-modified-id="15-4-2-Cloning-an-Rc<T>-Increases-the-Reference-Count-1.4.2">15-4-2 Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</a></span></li></ul></li><li><span><a href="#15-5-RefCell<T>-and-the-Interior-Mutability-Pattern" data-toc-modified-id="15-5-RefCell<T>-and-the-Interior-Mutability-Pattern-1.5">15-5 <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></span><ul class="toc-item"><li><span><a href="#15-5-1-Enforcing-Borrowing-Rules-at-Runtime-with-RefCell<T>" data-toc-modified-id="15-5-1-Enforcing-Borrowing-Rules-at-Runtime-with-RefCell<T>-1.5.1">15-5-1 Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></a></span></li><li><span><a href="#15-5-2-Interior-Mutability,-A-Mutable-Borrow-to-an-Immutable-Value" data-toc-modified-id="15-5-2-Interior-Mutability,-A-Mutable-Borrow-to-an-Immutable-Value-1.5.2">15-5-2 Interior Mutability, A Mutable Borrow to an Immutable Value</a></span><ul class="toc-item"><li><span><a href="#15-5-2-1-A-Use-Case-for-interior-Mutability,-Mock-Objects" data-toc-modified-id="15-5-2-1-A-Use-Case-for-interior-Mutability,-Mock-Objects-1.5.2.1">15-5-2-1 A Use Case for interior Mutability, Mock Objects</a></span></li><li><span><a href="#15-5-2-2-Keeping-Track-of-Borrows-at-Runtime-with-RefCell<T>" data-toc-modified-id="15-5-2-2-Keeping-Track-of-Borrows-at-Runtime-with-RefCell<T>-1.5.2.2">15-5-2-2 Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></a></span></li></ul></li><li><span><a href="#15-5-3-Having-Multiple-Owners-of-Mutable-Data-by-Combing-Rc<T>-and-RefCell<T>" data-toc-modified-id="15-5-3-Having-Multiple-Owners-of-Mutable-Data-by-Combing-Rc<T>-and-RefCell<T>-1.5.3">15-5-3 Having Multiple Owners of Mutable Data by Combing <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></a></span></li></ul></li><li><span><a href="#15-6-Reference-Cycles-Can-Leak-Memory" data-toc-modified-id="15-6-Reference-Cycles-Can-Leak-Memory-1.6">15-6 Reference Cycles Can Leak Memory</a></span><ul class="toc-item"><li><span><a href="#15-6-1-Creating-a-Reference-Cycle" data-toc-modified-id="15-6-1-Creating-a-Reference-Cycle-1.6.1">15-6-1 Creating a Reference Cycle</a></span></li><li><span><a href="#15-6-2-Preventing-Reference-Cycles,-Turning-an-Rc<T>-into-a-Weak<T>" data-toc-modified-id="15-6-2-Preventing-Reference-Cycles,-Turning-an-Rc<T>-into-a-Weak<T>-1.6.2">15-6-2 Preventing Reference Cycles, Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></a></span><ul class="toc-item"><li><span><a href="#15-6-2-1-Creating-a-Tree-Data-Structure,-a-Node-with-Child-Nodes" data-toc-modified-id="15-6-2-1-Creating-a-Tree-Data-Structure,-a-Node-with-Child-Nodes-1.6.2.1">15-6-2-1 Creating a Tree Data Structure, a Node with Child Nodes</a></span></li><li><span><a href="#15-6-2-2-Adding-a-Reference-from-a-Child-to-Its-Parent" data-toc-modified-id="15-6-2-2-Adding-a-Reference-from-a-Child-to-Its-Parent-1.6.2.2">15-6-2-2 Adding a Reference from a Child to Its Parent</a></span></li><li><span><a href="#15-6-2-3-Visualizing-Changes-to-strong_count-and-weak_count" data-toc-modified-id="15-6-2-3-Visualizing-Changes-to-strong_count-and-weak_count-1.6.2.3">15-6-2-3 Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></a></span></li></ul></li></ul></li></ul></li><li><span><a href="#16-Fearless-Concurrency" data-toc-modified-id="16-Fearless-Concurrency-2">16 Fearless Concurrency</a></span><ul class="toc-item"><li><span><a href="#16-1-Using-Threads-to-Run-Code-Simultaneously" data-toc-modified-id="16-1-Using-Threads-to-Run-Code-Simultaneously-2.1">16-1 Using Threads to Run Code Simultaneously</a></span><ul class="toc-item"><li><span><a href="#16-1-1-Creating-a-New-Thread-with-spawn" data-toc-modified-id="16-1-1-Creating-a-New-Thread-with-spawn-2.1.1">16-1-1 Creating a New Thread with <code>spawn</code></a></span></li><li><span><a href="#16-1-2-Waiting-for-All-Threads-to-Finish-Using-join-Handles" data-toc-modified-id="16-1-2-Waiting-for-All-Threads-to-Finish-Using-join-Handles-2.1.2">16-1-2 Waiting for All Threads to Finish Using <code>join</code> Handles</a></span></li><li><span><a href="#16-1-3-Using-move-Closures-with-Threads" data-toc-modified-id="16-1-3-Using-move-Closures-with-Threads-2.1.3">16-1-3 Using <code>move</code> Closures with Threads</a></span></li></ul></li><li><span><a href="#16-2-Using-Message-Passing-to-Transfer-Data-Between-Threads" data-toc-modified-id="16-2-Using-Message-Passing-to-Transfer-Data-Between-Threads-2.2">16-2 Using Message Passing to Transfer Data Between Threads</a></span><ul class="toc-item"><li><span><a href="#16-2-1-Channels-and-Ownership-Transference" data-toc-modified-id="16-2-1-Channels-and-Ownership-Transference-2.2.1">16-2-1 Channels and Ownership Transference</a></span></li><li><span><a href="#16-2-2-Sending-Multiple-Values-and-Seeing-the-Receiver-Waiting" data-toc-modified-id="16-2-2-Sending-Multiple-Values-and-Seeing-the-Receiver-Waiting-2.2.2">16-2-2 Sending Multiple Values and Seeing the Receiver Waiting</a></span></li><li><span><a href="#16-2-3-Creating-Multiple-Producers-by-Cloning-the-Transmitter" data-toc-modified-id="16-2-3-Creating-Multiple-Producers-by-Cloning-the-Transmitter-2.2.3">16-2-3 Creating Multiple Producers by Cloning the Transmitter</a></span></li></ul></li><li><span><a href="#16-3-Shared-State-Concurrency" data-toc-modified-id="16-3-Shared-State-Concurrency-2.3">16-3 Shared-State Concurrency</a></span><ul class="toc-item"><li><span><a href="#16-3-1-Using-Mutexes-to-Allow-Access-to-Data-from-One-Thread-at-a-Time" data-toc-modified-id="16-3-1-Using-Mutexes-to-Allow-Access-to-Data-from-One-Thread-at-a-Time-2.3.1">16-3-1 Using Mutexes to Allow Access to Data from One Thread at a Time</a></span><ul class="toc-item"><li><span><a href="#16-3-1-1-The-API-of-Mutex<T>" data-toc-modified-id="16-3-1-1-The-API-of-Mutex<T>-2.3.1.1">16-3-1-1 The API of <code>Mutex&lt;T&gt;</code></a></span></li><li><span><a href="#16-3-1-2-Sharing-a-Mutex<T>-Between-Multiple-Threads" data-toc-modified-id="16-3-1-2-Sharing-a-Mutex<T>-Between-Multiple-Threads-2.3.1.2">16-3-1-2 Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</a></span></li><li><span><a href="#16-3-1-3-Multiple-Ownership-with-Multiple-Threads" data-toc-modified-id="16-3-1-3-Multiple-Ownership-with-Multiple-Threads-2.3.1.3">16-3-1-3 Multiple Ownership with Multiple Threads</a></span></li><li><span><a href="#16-3-1-4-Atomic-Reference-Counting-with-Arc<T>" data-toc-modified-id="16-3-1-4-Atomic-Reference-Counting-with-Arc<T>-2.3.1.4">16-3-1-4 Atomic Reference Counting with <code>Arc&lt;T&gt;</code></a></span></li></ul></li><li><span><a href="#16-3-2-Similarities-Between-RefCell<T>/Rc<T>-and-Mutex<T>/Arc<T>" data-toc-modified-id="16-3-2-Similarities-Between-RefCell<T>/Rc<T>-and-Mutex<T>/Arc<T>-2.3.2">16-3-2 Similarities Between <code>RefCell&lt;T&gt;/Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;/Arc&lt;T&gt;</code></a></span></li></ul></li><li><span><a href="#16-4-Extensible-Concurrency-with-the-Sync-and-Send-Traits" data-toc-modified-id="16-4-Extensible-Concurrency-with-the-Sync-and-Send-Traits-2.4">16-4 Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</a></span><ul class="toc-item"><li><span><a href="#16-4-1-Allowing-Transference-of-Ownership-Between-Threads-with-Send" data-toc-modified-id="16-4-1-Allowing-Transference-of-Ownership-Between-Threads-with-Send-2.4.1">16-4-1 Allowing Transference of Ownership Between Threads with <code>Send</code></a></span></li><li><span><a href="#16-4-2-Allowing-Access-from-Multiple-Threads-with-Sync" data-toc-modified-id="16-4-2-Allowing-Access-from-Multiple-Threads-with-Sync-2.4.2">16-4-2 Allowing Access from Multiple Threads with <code>Sync</code></a></span></li><li><span><a href="#16-4-3-Implementing-Send-and-Sync-Manually-Is-Unsafe" data-toc-modified-id="16-4-3-Implementing-Send-and-Sync-Manually-Is-Unsafe-2.4.3">16-4-3 Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</a></span></li></ul></li></ul></li><li><span><a href="#19-Advanced-Features" data-toc-modified-id="19-Advanced-Features-3">19 Advanced Features</a></span><ul class="toc-item"><li><span><a href="#19-1-Unsafe-Rust" data-toc-modified-id="19-1-Unsafe-Rust-3.1">19-1 Unsafe Rust</a></span><ul class="toc-item"><li><span><a href="#19-1-1-Unsafe-Superpowers" data-toc-modified-id="19-1-1-Unsafe-Superpowers-3.1.1">19-1-1 Unsafe Superpowers</a></span></li><li><span><a href="#19-1-2-Dereferencing-a-Raw-Pointer" data-toc-modified-id="19-1-2-Dereferencing-a-Raw-Pointer-3.1.2">19-1-2 Dereferencing a Raw Pointer</a></span></li><li><span><a href="#19-1-3-Calling-an-Unsafe-Function-or-Method" data-toc-modified-id="19-1-3-Calling-an-Unsafe-Function-or-Method-3.1.3">19-1-3 Calling an Unsafe Function or Method</a></span><ul class="toc-item"><li><span><a href="#19-1-3-1-Creating-a-Safe-Abstraction-over-Unsafe-Code" data-toc-modified-id="19-1-3-1-Creating-a-Safe-Abstraction-over-Unsafe-Code-3.1.3.1">19-1-3-1 Creating a Safe Abstraction over Unsafe Code</a></span></li><li><span><a href="#19-1-3-2-Using-extern-Functions-to-Call-External-Code" data-toc-modified-id="19-1-3-2-Using-extern-Functions-to-Call-External-Code-3.1.3.2">19-1-3-2 Using <code>extern</code> Functions to Call External Code</a></span></li></ul></li><li><span><a href="#19-1-4-Accessing-or-Modifying-a-Mutable-Static-Variable" data-toc-modified-id="19-1-4-Accessing-or-Modifying-a-Mutable-Static-Variable-3.1.4">19-1-4 Accessing or Modifying a Mutable Static Variable</a></span></li><li><span><a href="#19-1-5-Implementing-an-Unsafe-Trait" data-toc-modified-id="19-1-5-Implementing-an-Unsafe-Trait-3.1.5">19-1-5 Implementing an Unsafe Trait</a></span></li></ul></li><li><span><a href="#19-2-Advanced-Traits" data-toc-modified-id="19-2-Advanced-Traits-3.2">19-2 Advanced Traits</a></span><ul class="toc-item"><li><span><a href="#19-2-1-Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types" data-toc-modified-id="19-2-1-Specifying-Placeholder-Types-in-Trait-Definitions-with-Associated-Types-3.2.1">19-2-1 Specifying Placeholder Types in Trait Definitions with Associated Types</a></span></li><li><span><a href="#19-2-2-Default-Generic-Type--Parameters-and-Operator-Overloading" data-toc-modified-id="19-2-2-Default-Generic-Type--Parameters-and-Operator-Overloading-3.2.2">19-2-2 Default Generic Type  Parameters and Operator Overloading</a></span></li><li><span><a href="#19-2-3-Fully-Qualified-Syntax-for-Disambiguation,-Calling-Methods-with-the-Same-Name" data-toc-modified-id="19-2-3-Fully-Qualified-Syntax-for-Disambiguation,-Calling-Methods-with-the-Same-Name-3.2.3">19-2-3 Fully Qualified Syntax for Disambiguation, Calling Methods with the Same Name</a></span></li><li><span><a href="#19-2-4-Using-Supertraits-to-Require-One-Trait's-Functionality-Within-Another-Trait" data-toc-modified-id="19-2-4-Using-Supertraits-to-Require-One-Trait's-Functionality-Within-Another-Trait-3.2.4">19-2-4 Using Supertraits to Require One Trait's Functionality Within Another Trait</a></span></li><li><span><a href="#19-2-5-Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types" data-toc-modified-id="19-2-5-Using-the-Newtype-Pattern-to-Implement-External-Traits-on-External-Types-3.2.5">19-2-5 Using the Newtype Pattern to Implement External Traits on External Types</a></span></li></ul></li><li><span><a href="#19-3-Advanced-Types" data-toc-modified-id="19-3-Advanced-Types-3.3">19-3 Advanced Types</a></span><ul class="toc-item"><li><span><a href="#19-3-1-Using-the-Newtype-Pattern-for-Type-Safety-and-Abstraction" data-toc-modified-id="19-3-1-Using-the-Newtype-Pattern-for-Type-Safety-and-Abstraction-3.3.1">19-3-1 Using the Newtype Pattern for Type Safety and Abstraction</a></span></li><li><span><a href="#19-3-2-Creating-Type-Synonyms-with-Type-Aliases" data-toc-modified-id="19-3-2-Creating-Type-Synonyms-with-Type-Aliases-3.3.2">19-3-2 Creating Type Synonyms with Type Aliases</a></span></li><li><span><a href="#19-3-3-The-Never-Type-that-Never-Returns" data-toc-modified-id="19-3-3-The-Never-Type-that-Never-Returns-3.3.3">19-3-3 The Never Type that Never Returns</a></span></li><li><span><a href="#19-3-4-Dynamically-Sized-Types-and-the-Sized-Trait" data-toc-modified-id="19-3-4-Dynamically-Sized-Types-and-the-Sized-Trait-3.3.4">19-3-4 Dynamically Sized Types and the <code>Sized</code> Trait</a></span></li></ul></li><li><span><a href="#19-4-Advanced-Functions-and-Closures" data-toc-modified-id="19-4-Advanced-Functions-and-Closures-3.4">19-4 Advanced Functions and Closures</a></span><ul class="toc-item"><li><span><a href="#19-4-1-Function-Pointers" data-toc-modified-id="19-4-1-Function-Pointers-3.4.1">19-4-1 Function Pointers</a></span></li><li><span><a href="#19-4-2-Returning-Closures" data-toc-modified-id="19-4-2-Returning-Closures-3.4.2">19-4-2 Returning Closures</a></span></li></ul></li><li><span><a href="#19-5-Macros" data-toc-modified-id="19-5-Macros-3.5">19-5 Macros</a></span><ul class="toc-item"><li><span><a href="#19-5-1-The-Difference-Between-Macros-and-Functions" data-toc-modified-id="19-5-1-The-Difference-Between-Macros-and-Functions-3.5.1">19-5-1 The Difference Between Macros and Functions</a></span></li><li><span><a href="#19-5-2-Declarative-Macros-with-macro_rules!-for-General-Metaprogramming" data-toc-modified-id="19-5-2-Declarative-Macros-with-macro_rules!-for-General-Metaprogramming-3.5.2">19-5-2 Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</a></span></li><li><span><a href="#19-5-3-Procedural-Macros-for-Generating-Code-from-Attributes" data-toc-modified-id="19-5-3-Procedural-Macros-for-Generating-Code-from-Attributes-3.5.3">19-5-3 Procedural Macros for Generating Code from Attributes</a></span></li><li><span><a href="#19-5-4-How-to-Write-a-Custom-derive-Macro" data-toc-modified-id="19-5-4-How-to-Write-a-Custom-derive-Macro-3.5.4">19-5-4 How to Write a Custom <code>derive</code> Macro</a></span></li><li><span><a href="#19-5-5-Attribute-like-macros" data-toc-modified-id="19-5-5-Attribute-like-macros-3.5.5">19-5-5 Attribute-like macros</a></span></li><li><span><a href="#19-5-6-Function-like-macros" data-toc-modified-id="19-5-6-Function-like-macros-3.5.6">19-5-6 Function-like macros</a></span></li></ul></li></ul></li></ul></div>
<h2 id="15-smart-pointers">15 Smart Pointers</h2>
<p>Reference counting smart pointer enables you to have multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data.</p>
<p>References are pointers that only borrow data; in contrast, in many cases, smart pointers <em>own</em> the data they point to.</p>
<p>Smart pointers are usually implemented using structs. The characteristic that distinguishes a smart pointer from an ordinary struct is that smart pointers implement the <code>Deref</code> and <code>Drop</code> traits.</p>
<ul>
<li>The <code>Deref</code> trait allows an instance of the smart pointer struct to behave like a reference so you can write code that works with either references or smart pointers.</li>
<li>The <code>Drop</code> trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
<a id="more"></a>
<h3 id="15-1-using-box-to-point-to-data-on-the-heap">15-1 Using Box to Point to Data on the Heap</h3>
<p>The most straightforward smart pointer is a <em>box</em>, which allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data.</p>
<p>Boxes don’t have performance overhead, other than storing their data on the heap instead of on the stack. Some situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size (See Enabling Recursive Types with Boxes).</li>
<li>When you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so
<ul>
<li>Transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box.</li>
<li>Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap.</li>
</ul>
</li>
<li>When you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type (Ch17, Using Trait Objects That Allow for Values of Different Types).</li>
</ul>
<h4 id="15-1-1-using-a-box-t-to-store-data-on-the-heap">15-1-1 Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just like any owned value, when a box goes out of scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The deallocation happens for the box (stored on the stack) and the data it points to (stored on the heap).</p>
<h4 id="15-1-2-enabling-recursive-types-with-boxes">15-1-2 Enabling Recursive Types with Boxes</h4>
<p>One type whose size can’t be known at compile time is a <em>recursive type</em>. Boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.</p>
<h5 id="15-1-2-1-more-information-about-the-cons-list">15-1-2-1 More Information About the Cons List</h5>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language and its dialects. “To cons <em>x</em> onto <em>y</em>” informally means to construct a new container instance by putting the element <em>x</em> at the start of this new container, followed by the container <em>y</em>.</p>
<p>Each item in a cons list contains two elements: the value of the current item and the next item. The last item in the list contains only a value called <code>Nil</code> without a next item. A cons list is produced by recursively calling the <code>cons</code> function. The canonical name to denote the base case of the recursion is <code>Nil</code>. Note that this is not the same as the “null” or “nil” concept in Chapter 6, which is an invalid or absent value.</p>
<p>Most of the time when you have a list of items in Rust, <code>Vec</code> is a better choice to use. More complex recursive data types <em>are</em> useful in various situations.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">	Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0072]: recursive type `List` has infinite size</span></span><br></pre></td></tr></table></figure>
<p>The reason is that we’ve defined <code>List</code> with a variant that is recursive, Rust can’t figure out how much space it needs to store a <code>list</code> value.</p>
<h5 id="15-1-2-2-computing-the-size-of-a-non-recursive-type">15-1-2-2 Computing the Size of a Non-Recursive Type</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">	Quit, </span><br><span class="line">    Move &#123;x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>&#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because only one variant will be used, the most space a <code>Message</code> value will need is the space it would take to store the largest of its variants.</p>
<h5 id="15-1-2-3-using-box-t-to-get-a-recursive-type-with-a-known-size">15-1-2-3 Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</h5>
<p>Instead of storing a value directly, we’ll change the data structure to store the value indirectly by storing a pointer to the value instead.</p>
<p>Because a <code>Box</code> is a pointer, Rust always knows how much space a <code>Box</code> needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we can put a <code>Box</code> inside the <code>Cons</code> variant instead of another <code>List</code> value directly. The <code>Box</code> will point to the next <code>List</code> value that will be on the heap rather than inside the <code>Cons</code> variant. Conceptually, we still have a list, created with lists “holding” other lists, but this implementation is now more like placing the items next to one another rather than inside one another.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">	Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the box’s pointer data.</p>
<p><img src="https://doc.rust-lang.org/stable/book/img/trpl15-02.svg" alt></p>
<p>The <code>Box</code> type is a smart pointer because it implements the <code>Deref</code> trait, which allows <code>Box</code> values to be treated like references.  When a <code>Box</code> value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the <code>Drop</code> trait implementation.</p>
<h3 id="15-2-treating-smart-pointers-like-regular-references-with-the-deref-trait">15-2 Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</h3>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the <em>dereference operator</em>, <code>*</code>. By implementing <code>Deref</code> in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.</p>
<h4 id="15-2-1-following-the-pointer-to-the-value-with-the-dereference-operator">15-2-1 Following the Pointer to the Value with the Dereference Operator</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;x;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="comment">// use *y to follow the reference to the value it’s pointing to (hence dereference). </span></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-2-2-using-box-t-like-a-reference">15-2-2 Using <code>Box&lt;T&gt;</code> Like a Reference</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here we set <code>y</code> to be an instance of a box pointing to the value in <code>x</code> rather than a reference pointing to the value of <code>x</code>.</p>
<h4 id="15-2-3-defining-our-own-smart-pointer">15-2-3 Defining Our Own Smart Pointer</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    	MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0614]: type `MyBox&lt;&#123;integer&#125;&gt;` cannot be dereferenced</span></span><br></pre></td></tr></table></figure>
<p>Because we haven’t implemented that ability on our type. To enable dereferencing with the <code>*</code> operator, we implement the <code>Deref</code> trait.</p>
<h4 id="15-2-4-treating-a-type-like-a-reference-by-implementing-the-deref-trait">15-2-4 Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</h4>
<p>The <code>Deref</code> trait, provided by the standard library, requires us to implement one method named <code>deref</code> that borrows <code>self</code> and returns a reference to the inner data.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// defines an associated type for the Deref trait to use</span></span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &amp;self.0, returns a reference to the value we want to access with the * operator</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">    	&amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references. The <code>deref</code> method gives the compiler the ability to take a value of any type that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that it knows how to dereference.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*y </span><br><span class="line"><span class="comment">// means</span></span><br><span class="line">*(y.deref())</span><br></pre></td></tr></table></figure>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the plain dereference outside the parentheses in <code>*(y.deref())</code> is still necessary, is the ownership system.</p>
<ul>
<li>If the <code>deref</code> method returned the value directly instead of a reference to the value, the value would be moved out of <code>self</code>.</li>
<li>We don’t want to take ownership of the inner value inside <code>MyBox</code> in this case or in most cases where we use the dereference operator.</li>
</ul>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.</p>
<h4 id="15-2-5-implicit-deref-coercions-with-functions-and-methods">15-2-5 Implicit Deref Coercions with Functions and Methods</h4>
<p>Deref coercion converts a reference to a type that implements <code>Deref</code> into a reference to a type that <code>Deref</code> can convert the original type into. Deref coercion happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the <code>deref</code> method converts the type we provided into the type the parameter needs.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because we implemented the <code>Deref</code> trait on <code>MyBox</code>, Rust can turn <code>&amp;MyBox</code> into <code>&amp;String</code> by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code> on <code>String</code> that returns a string slice, and this is in the API documentation for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which matches the <code>hello</code> function’s definition.</p>
<p>If Rust didn’t implement deref coercion:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>(*m)</code> dereferences the <code>MyBox</code> into a <code>String</code>. Then the <code>&amp;</code> and <code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to match the signature of <code>hello</code>.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the types and use <code>Deref::deref</code> as many times as necessary to get a reference to match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!</p>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/deref" target="_blank" rel="noopener">here</a>.</p>
<h4 id="15-2-6-how-deref-coercion-interacts-with-mutability">15-2-6 How Deref Coercion Interacts with Mutability</h4>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code> operator on mutable references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is <em>not</em> possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that there is only one immutable reference to that data, and the borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.</p>
<h3 id="15-3-running-code-on-cleanup-with-the-drop-trait">15-3 Running Code on Cleanup with the <code>Drop</code> Trait</h3>
<p><code>Drop</code> lets you customize what happens when a value is about to go out of scope. The <code>Drop</code> trait is almost always used when implementing a smart pointer. For example, <code>Box</code> customizes <code>Drop</code> to deallocate the space on the heap that the box points to.</p>
<p>In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. The <code>Drop</code> trait requires you to implement one method named <code>drop</code> that takes a mutable reference to <code>self</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">	data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> c = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"my stuff"</span>) &#125;;</span><br><span class="line">    <span class="keyword">let</span> d = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"other staff"</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointers created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomSmartPointers created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></table></figure>
<h4 id="15-3-1-dropping-a-value-early-with-std-mem-drop">15-3-1 Dropping a Value Early with <code>std::mem::drop</code></h4>
<p>Unfortunately, it’s not straightforward to disable the automatic <code>drop</code> functionality. Disabling <code>drop</code> isn’t usually necessary; the whole point of the <code>Drop</code> trait is that it’s taken care of automatically.</p>
<p>Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the <code>drop</code> method that releases the lock to run so other code in the same scope can acquire the lock.</p>
<p>Rust doesn’t let you call the <code>Drop</code> trait’s <code>drop</code> method manually; instead you have to call the <code>std::mem::drop</code> function provided by the standard library if you want to force a value to be dropped before the end of its scope.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> c = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created"</span>);</span><br><span class="line">    c.<span class="built_in">drop</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0040]: explicit use of destructor method</span></span><br></pre></td></tr></table></figure>
<p>We’re not allowed to explicitly call <code>drop</code>. The error message uses the term <em>destructor</em>, which is the general programming term for a function that cleans up an instance.</p>
<p>A <em>destructor</em> is analogous to a <em>constructor</em>, which creates an instance. The <code>drop</code> function in Rust is one particular destructor.</p>
<p>Rust doesn’t let us call <code>drop</code> explicitly because Rust would still automatically call <code>drop</code> on the value at the end of <code>main</code>. This would be a <em>double free</em> error because Rust would be trying to clean up the same value twice.</p>
<p>The <code>std::mem::drop</code> function is different from the <code>drop</code> method in the <code>Drop</code> trait. We call it by passing the value we want to force to be dropped early as an argument.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123; data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>);</span><br><span class="line">    <span class="built_in">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main."</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// Dropping CustomSmartPointer with data `some data`!</span></span><br><span class="line"><span class="comment">// CustomSmartPointer dropped before the end of main.</span></span><br></pre></td></tr></table></figure>
<h3 id="15-4-rc-t-the-reference-counted-smart-pointer">15-4 <code>Rc&lt;T&gt;</code> the Reference Counted Smart Pointer</h3>
<p>When a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn’t be cleaned up unless it doesn’t have any edges pointing to it.</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc</code>, which is an abbreviation for <em>reference counting</em>. The <code>Rc</code> type keeps track of the number of references to a value which determines whether or not a value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.</p>
<p>We use the <code>Rc</code> type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.</p>
<p>Note that <code>Rc</code> is only for use in single-threaded scenarios.</p>
<h4 id="15-4-1-using-rc-t-to-share-data">15-4-1 Using <code>Rc&lt;T&gt;</code> to Share Data</h4>
<p><img src="https://doc.rust-lang.org/stable/book/img/trpl15-03.svg" alt></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">10</span>, <span class="built_in">Box</span>::new(Nil))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0382]: use of moved value: `a`</span></span><br></pre></td></tr></table></figure>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code> is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. The borrow checker wouldn’t let us compile <code>let a = Cons(10, &amp;Nil);</code> for example, because the temporary <code>Nil</code> value would be dropped before <code>a</code> could take a reference to it.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Each Cons variant will now hold a value and an Rc&lt;T&gt; pointing to a List</span></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="comment">// clone the Rc&lt;List&gt; that a is holding</span></span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="comment">// increasing the number of references from two to three</span></span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Every time we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc</code> will increase, and the data won’t be cleaned up unless there are zero references to it.</p>
<p>The implementation of <code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’ implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the reference count, which doesn’t take much time.</p>
<h4 id="15-4-2-cloning-an-rc-t-increases-the-reference-count">15-4-2 Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// count after creating a = 1</span></span><br><span class="line"><span class="comment">// count after creating b = 2</span></span><br><span class="line"><span class="comment">// count after creating c = 3</span></span><br><span class="line"><span class="comment">// count after c goes out of scope = 2</span></span><br></pre></td></tr></table></figure>
<p>The implementation of the <code>Drop</code> trait decreases the reference count automatically when an <code>Rc</code> value goes out of scope.</p>
<h3 id="15-5-refcell-t-and-the-interior-mutability-pattern">15-5 <code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</h3>
<h4 id="15-5-1-enforcing-borrowing-rules-at-runtime-with-refcell-t">15-5-1 Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></h4>
<p>Unlike <code>Rc</code>, the <code>RefCell</code> type represents single ownership over the data it holds.</p>
<ul>
<li>With references and <code>Box</code>, the borrowing rules’ invariants are enforced at compile time. With <code>RefCell</code>, these invariants are enforced <em>at runtime</em>.</li>
<li>With references, if you break these rules, you’ll get a compiler error. With <code>RefCell</code>, if you break these rules, your program will panic and exit.</li>
</ul>
<p>The advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust’s default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative.</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The <code>RefCell</code> type is useful <strong>when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that</strong>.</p>
<p>Similar to <code>Rc</code>, <code>RefCell</code> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context.</p>
<p>A recap of the reasons to choose <code>Box</code>, <code>Rc</code>, or <code>RefCell</code>:</p>
<ul>
<li><code>Rc</code> enables multiple owners of the same data; <code>Box</code> and <code>RefCell</code> have single owners.</li>
<li><code>Box</code> allows immutable or mutable borrows checked at compile time; <code>Rc</code> allows only immutable borrows checked at compile time; <code>RefCell</code> allows immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell</code> allows mutable borrows checked at runtime, you can mutate the value inside the <code>RefCell</code> even when the <code>RefCell</code> is immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em> pattern.</p>
<h4 id="15-5-2-interior-mutability-a-mutable-borrow-to-an-immutable-value">15-5-2 Interior Mutability, A Mutable Borrow to an Immutable Value</h4>
<p>A consequence of the borrowing rules is that when you have an immutable value, you can’t borrow it mutably.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0596]: cannot borrow immutable local variable `x` as mutable</span></span><br></pre></td></tr></table></figure>
<p>However, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value’s methods would not be able to mutate the value. Using <code>RefCell</code> is one way to get the ability to have interior mutability. But <code>RefCell</code> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of a compiler error.</p>
<h5 id="15-5-2-1-a-use-case-for-interior-mutability-mock-objects">15-5-2-1 A Use Case for interior Mutability, Mock Objects</h5>
<p>A <em>test double</em> is the general programming concept for a type used in place of another type during testing. <em>Mock objects</em> are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. Our library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called <code>Messenger</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="comment">// send that takes an immutable reference to self and the text of the message. </span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line">    <span class="keyword">where</span> T: Messenger &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You are over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">             <span class="keyword">self</span>.messenger.send(<span class="string">"Urgent warning: You've used up over 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Warning: You've used up over 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We need a mock object that, instead of sending an email or text message when we call <code>send</code>, will only keep track of the messages it’s told to send.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: <span class="built_in">vec!</span>[] &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable</span></span><br></pre></td></tr></table></figure>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the <code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the suggestion from the error text to use <code>&amp;mut self</code> instead, because then the signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait definition.</p>
<p>This is a situation in which interior mutability can help! We’ll store the <code>sent_messages</code> within a <code>RefCell</code>, and then the <code>send</code> message will be able to modify <code>sent_messages</code> to store the messages we’ve seen.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123; sent_messages: RefCell::new(<span class="built_in">vec!</span>[]) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">		<span class="comment">// call borrow on the RefCell&lt;Vec&lt;String&gt;&gt; to get an immutable reference to the vector.</span></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For the implementation of the <code>send</code> method, the first parameter is still an immutable borrow of <code>self</code>, which matches the trait definition. We call <code>borrow_mut</code> on the <code>RefCell&gt;</code> in <code>self.sent_messages</code> to get a mutable reference to the value inside the <code>RefCell&gt;</code>, which is the vector. Then we can call <code>push</code> on the mutable reference to the vector to keep track of the messages sent during the test.</p>
<h5 id="15-5-2-2-keeping-track-of-borrows-at-runtime-with-refcell-t">15-5-2-2 Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></h5>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code> syntax, respectively. With <code>RefCell</code>, we use the <code>borrow</code> and <code>borrow_mut</code> methods, which are part of the safe API that belongs to <code>RefCell</code>. The <code>borrow</code> method returns the smart pointer type <code>Ref</code>, and <code>borrow_mut</code> returns the smart pointer type <code>RefMut</code>. Both types implement <code>Deref</code>, so we can treat them like regular references.</p>
<p>The <code>RefCell</code> keeps track of how many <code>Ref</code> and <code>RefMut</code> smart pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell</code> increases its count of how many immutable borrows are active. When a <code>Ref</code> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, <code>RefCell</code> lets us have many immutable borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of <code>RefCell</code> will panic at runtime. We’re deliberately trying to create two mutable borrows active for the same scope to illustrate that <code>RefCell</code> prevents us from doing this at runtime.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> one_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> two_borrow = <span class="keyword">self</span>.sent_messages.borrow_mut();</span><br><span class="line"></span><br><span class="line">        one_borrow.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        two_borrow.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// already borrowed: BorrowMutError. </span></span><br><span class="line"><span class="comment">// This is how RefCell&lt;T&gt; handles violations of the borrowing rules at runtime.</span></span><br></pre></td></tr></table></figure>
<p>Catching borrowing errors at runtime rather than compile time means that you would find a mistake in your code later in the development process and possibly not until your code was deployed to production. Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time. However, using <code>RefCell</code> makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you’re using it in a context where only immutable values are allowed. You can use <code>RefCell</code> despite its trade-offs to get more functionality than regular references provide.</p>
<h4 id="15-5-3-having-multiple-owners-of-mutable-data-by-combing-rc-t-and-refcell-t">15-5-3 Having Multiple Owners of Mutable Data by Combing <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></h4>
<p>A common way to use <code>RefCell</code> is in combination with <code>Rc</code>. Recall that <code>Rc</code> lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an <code>Rc</code> that holds a <code>RefCell</code>, you can get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a after = Cons(RefCell &#123; value: 15 &#125;, Nil)</span></span><br><span class="line"><span class="comment">// b after = Cons(RefCell &#123; value: 6 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span></span><br><span class="line"><span class="comment">// c after = Cons(RefCell &#123; value: 10 &#125;, Cons(RefCell &#123; value: 15 &#125;, Nil))</span></span><br></pre></td></tr></table></figure>
<p>We need to clone <code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from <code>value</code>.</p>
<p>The <code>borrow_mut</code> method uses the automatic dereferencing feature to dereference the <code>Rc</code> to the inner <code>RefCell</code> value, returns a <code>RefMut</code> smart pointer, and we use the dereference operator on it and change the inner value.</p>
<p>By using <code>RefCell</code>, we have an outwardly immutable <code>List</code> value. But we can use the methods on <code>RefCell</code> that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures.</p>
<p>The standard library has other types that provide interior mutability, such as <code>Cell</code>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the <code>Cell</code>. There’s also <code>Mutex</code>, which offers interior mutability that’s safe to use across threads.</p>
<h3 id="15-6-reference-cycles-can-leak-memory">15-6 Reference Cycles Can Leak Memory</h3>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a <em>memory leak</em>).</p>
<p>Preventing memory leaks entirely is not one of Rust’s guarantees in the same way that disallowing data races at compile time is, meaning memory leaks are memory safe in Rust.</p>
<p>We can see that Rust allows memory leaks by using <code>Rc</code> and <code>RefCell</code>: it’s possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.</p>
<h4 id="15-6-1-creating-a-reference-cycle">15-6-1 Creating a Reference Cycle</h4>
<p>Let’s look at how a reference cycle might happen and how to prevent it:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    <span class="comment">// we want to modify which List value a Cons variant is pointing to. </span></span><br><span class="line">    Cons(<span class="built_in">i32</span>, RefCell&lt;Rc&lt;List&gt;&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> List &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">tail</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            Cons(_, item) =&gt; <span class="literal">Some</span>(item),</span><br><span class="line">            Nil =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code creates a list in <code>a</code> and a list in <code>b</code> that points to the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a reference cycle.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, RefCell::new(Rc::new(Nil))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a initial rc count = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a next item = &#123;:?&#125;"</span>, a.tail());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> b = Rc::new(Cons(<span class="number">10</span>, RefCell::new(Rc::clone(&amp;a))));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a rc count after b creation = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b initial rc count = &#123;&#125;"</span>, Rc::strong_count(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b next item = &#123;:?&#125;"</span>, b.tail());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(link) = a.tail() &#123;</span><br><span class="line">        *link.borrow_mut() = Rc::clone(&amp;b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b rc count after changing a = &#123;&#125;"</span>, Rc::strong_count(&amp;b));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a rc count after changing a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Uncomment the next line to see that we have a cycle;</span></span><br><span class="line">    <span class="comment">// it will overflow the stack</span></span><br><span class="line">    <span class="comment">// println!("a next item = &#123;:?&#125;", a.tail());</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a initial rc count = 1</span></span><br><span class="line"><span class="comment">// a next item = Some(RefCell &#123; value: Nil &#125;)</span></span><br><span class="line"><span class="comment">// a rc count after b creation = 2</span></span><br><span class="line"><span class="comment">// b initial rc count = 1</span></span><br><span class="line"><span class="comment">// b next item = Some(RefCell &#123; value: Cons(5, RefCell &#123; value: Nil &#125;) &#125;)</span></span><br><span class="line"><span class="comment">// b rc count after changing a = 2</span></span><br><span class="line"><span class="comment">// a rc count after changing a = 2</span></span><br></pre></td></tr></table></figure>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We do that by using the <code>tail</code> method to get a reference to the <code>RefCell&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then we use the <code>borrow_mut</code> method on the <code>RefCell&gt;</code> to change the value inside from an <code>Rc</code> that holds a <code>Nil</code> value to the <code>Rc</code> in <code>b</code>.</p>
<p><img src="https://doc.rust-lang.org/stable/book/img/trpl15-04.svg" alt></p>
<p>In this case, right after we create the reference cycle, the program ends. The consequences of this cycle aren’t very dire. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.</p>
<p>If you have <code>RefCell</code> values that contain <code>Rc</code> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them.</p>
<p>Another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing above, we always want <code>Cons</code> variants to own their list, so reorganizing the data structure isn’t possible.</p>
<h4 id="15-6-2-preventing-reference-cycles-turning-an-rc-t-into-a-weak-t">15-6-2 Preventing Reference Cycles, Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></h4>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the <code>strong_count</code> of an <code>Rc</code> instance, and an <code>Rc</code> instance is only cleaned up if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the value within an <code>Rc</code> instance by calling <code>Rc::downgrade</code> and passing a reference to the <code>Rc</code>. When you call <code>Rc::downgrade</code>, you get a smart pointer of type <code>Weak</code>. Instead of increasing the <code>strong_count</code> in the <code>Rc</code> instance by 1, calling <code>Rc::downgrade</code> increases the <code>weak_count</code> by 1. The <code>Rc</code> type uses <code>weak_count</code> to keep track of how many <code>Weak</code> references exist, similar to <code>strong_count</code>. The difference is the <code>weak_count</code> doesn’t need to be 0 for the <code>Rc</code> instance to be cleaned up.</p>
<p>Strong references are how you can share ownership of an <code>Rc</code> instance. Weak references don’t express an ownership relationship. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.</p>
<p>Because the value that <code>Weak</code> references might have been dropped, to do anything with the value that a <code>Weak</code> is pointing to, you must make sure the value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak</code> instance, which will return an <code>Option&gt;</code>. You’ll get a result of <code>Some</code> if the <code>Rc</code> value has not been dropped yet and a result of <code>None</code> if the <code>Rc</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option</code>, Rust will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there won’t be an invalid pointer.</p>
<h5 id="15-6-2-1-creating-a-tree-data-structure-a-node-with-child-nodes">15-6-2-1 Creating a Tree Data Structure, a Node with Child Nodes</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with variables so we can access each <code>Node</code> in the tree directly.</p>
<p>To do this, we define the <code>Vec</code> items to be values of type <code>Rc</code>. We also want to modify which nodes are children of another node, so we have a <code>RefCell</code> in <code>children</code> around the <code>Vec&gt;</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="15-6-2-2-adding-a-reference-from-a-child-to-its-parent">15-6-2-2 Adding a Reference from a Child to Its Parent</h5>
<p>It can’t contain an <code>Rc</code>, because that would create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and <code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code> values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A node will be able to refer to its parent node but doesn’t own its parent.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;,</span></span><br><span class="line"><span class="comment">// children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;,</span></span><br><span class="line"><span class="comment">// children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span></span><br></pre></td></tr></table></figure>
<p>Once we have the <code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak</code> reference to its parent. We use the <code>borrow_mut</code> method on the <code>RefCell&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the <code>Rc::downgrade</code> function to create a <code>Weak</code> reference to <code>branch</code> from the <code>Rc</code> in <code>branch.</code></p>
<p>The lack of infinite output indicates that this code didn’t create a reference cycle. We can also tell this by looking at the values we get from calling <code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<h5 id="15-6-2-3-visualizing-changes-to-strong-count-and-weak-count">15-6-2-3 Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"leaf strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">            value: <span class="number">5</span>,</span><br><span class="line">            parent: RefCell::new(Weak::new()),</span><br><span class="line">            children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"branch strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">            Rc::strong_count(&amp;branch),</span><br><span class="line">            Rc::weak_count(&amp;branch),</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(</span><br><span class="line">            <span class="string">"leaf strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">            Rc::strong_count(&amp;leaf),</span><br><span class="line">            Rc::weak_count(&amp;leaf),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">    <span class="built_in">println!</span>(</span><br><span class="line">        <span class="string">"leaf strong = &#123;&#125;, weak = &#123;&#125;"</span>,</span><br><span class="line">        Rc::strong_count(&amp;leaf),</span><br><span class="line">        Rc::weak_count(&amp;leaf),</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br><span class="line"><span class="comment">// branch strong = 1, weak = 1</span></span><br><span class="line"><span class="comment">// leaf strong = 2, weak = 0</span></span><br><span class="line"><span class="comment">// leaf parent = None</span></span><br><span class="line"><span class="comment">// leaf strong = 1, weak = 0</span></span><br></pre></td></tr></table></figure>
<h2 id="16-fearless-concurrency">16 Fearless Concurrency</h2>
<p>The ownership and type systems are a powerful set of tools to help manage memory safety <em>and</em> concurrency problems!</p>
<h3 id="16-1-using-threads-to-run-code-simultaneously">16-1 Using Threads to Run Code Simultaneously</h3>
<p>Multiple threads problems:</p>
<ul>
<li>Race conditions</li>
<li>Deadlock</li>
<li>Bugs that happen only in certain situations</li>
</ul>
<p>Special implementation of threads:</p>
<ul>
<li>1:1</li>
<li>M:N</li>
</ul>
<p>What most important to Rust is runtime support. <em>Runtime</em> is a confusing term and can have different meanings in different contexts. In this context, by <em>runtime</em> we mean code that is included by the language in every binary. Rust needs to have nearly no runtime and cannot compromise on being able to call into C to maintain performance.</p>
<p>The green-threading M:N model requires a larger language runtime to manage threads. As such, the Rust standard library only provides an implementation of 1:1 threading. Because Rust is such a low-level language, there are crates that implement M:N threading if you would rather trade overhead for aspects such as more control over which threads run when and lower costs of context switching, for example.</p>
<h4 id="16-1-1-creating-a-new-thread-with-spawn">16-1-1 Creating a New Thread with <code>spawn</code></h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The new thread will be stopped when the main thread ends, whether or not it has finished running.</p>
<h4 id="16-1-2-waiting-for-all-threads-to-finish-using-join-handles">16-1-2 Waiting for All Threads to Finish Using <code>join</code> Handles</h4>
<p>We can fix the problem of the spawned thread not getting to run, or not getting to run completely, by saving the return value of <code>thread::spawn</code> in a variable. The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned value that, when we call the <code>join</code> method on it, will wait for its thread to finish.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 6 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 7 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 8 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 9 from the spawned thread!</span></span><br></pre></td></tr></table></figure>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the thread represented by the handle terminates. <em>Blocking</em> a thread means that thread is prevented from performing work or exiting.</p>
<p>The two threads continue alternating, but the main thread waits because of the call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hi number 1 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 5 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 6 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 7 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 8 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 9 from the spawned thread!</span></span><br><span class="line"><span class="comment">// hi number 1 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 2 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 3 from the main thread!</span></span><br><span class="line"><span class="comment">// hi number 4 from the main thread!</span></span><br></pre></td></tr></table></figure>
<h4 id="16-1-3-using-move-closures-with-threads">16-1-3 Using <code>move</code> Closures with Threads</h4>
<p>The <code>move</code> closure is often used alongside <code>thread::spawn</code> because it allows you to use data from one thread in another thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</span></span><br></pre></td></tr></table></figure>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t tell how long the spawned thread will run, so it doesn’t know if the reference to <code>v</code> will always be valid.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drop</span>(v); <span class="comment">// oh no!</span></span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// help: to force the closure to take ownership of `v` (and any other referenced variables), use the `move` keyword</span></span><br></pre></td></tr></table></figure>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take ownership of the values it’s using rather than allowing Rust to infer that it should borrow the values.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// If we added move to the closure, we would move v into the closure’s environment, and we could no longer call drop on it in the main thread. </span></span><br><span class="line">    <span class="comment">// drop(v);</span></span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="16-2-using-message-passing-to-transfer-data-between-threads">16-2 Using Message Passing to Transfer Data Between Threads</h3>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message passing</em>, where threads or actors communicate by sending each other messages containing data. Go slogan “Do not communicate by sharing memory; instead, share memory by communicating.”</p>
<p>One major tool Rust has for accomplishing message-sending concurrency is the <em>channel</em>. A channel in programming has two halves: a transmitter and a receiver. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be <em>closed</em> if either the transmitter or receiver half is dropped.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We create a new channel using the <code>mpsc::channel</code> function, it returns a tuple, the first element of which is the sending end and the second element is the receiving end. <code>mpsc</code> stands for <em>multiple producer, single consumer</em>.</p>
<p>The way Rust’s standard library implements channels means a channel can have multiple <em>sending</em> ends that produce values but only one <em>receiving</em> end that consumes those values.</p>
<p>The spawned thread needs to own the transmitting end of the channel to be able to send messages through the channel by using <code>move</code>.</p>
<p>The transmitting end has a <code>send</code> method that takes the value we want to send. The <code>send</code> method returns a <code>Result</code> type, so if the receiving end has already been dropped and there’s nowhere to send a value, the send operation will return an error. In this example, we’re calling <code>unwrap</code> to panic in case of an error. But in a real application, we would handle it properly.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>. We’re using <code>recv</code>, short for <em>receive</em>, which will block the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, <code>recv</code> will return it in a <code>Result</code>. When the sending end of the channel closes, <code>recv</code> will return an error to signal that no more values will be coming.</p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result</code> immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code> value if there aren’t any messages this time. Using <code>try_recv</code> is useful if this thread has other work to do while waiting for messages: we could write a loop that calls <code>try_recv</code> every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.</p>
<h4 id="16-2-1-channels-and-ownership-transference">16-2-1 Channels and Ownership Transference</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"val is &#123;&#125;"</span>, val);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0382]: use of moved value: `val`</span></span><br></pre></td></tr></table></figure>
<p>The <code>send</code> function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it.</p>
<h4 id="16-2-2-sending-multiple-values-and-seeing-the-receiver-waiting">16-2-2 Sending Multiple Values and Seeing the Receiver Waiting</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-2-3-creating-multiple-producers-by-cloning-the-transmitter">16-2-3 Creating Multiple Producers by Cloning the Transmitter</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx1.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">    <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"more"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"messages"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"for"</span>),</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"you"</span>),</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">        thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Got: hi</span></span><br><span class="line"><span class="comment">// Got: more</span></span><br><span class="line"><span class="comment">// Got: from</span></span><br><span class="line"><span class="comment">// Got: messages</span></span><br><span class="line"><span class="comment">// Got: for</span></span><br><span class="line"><span class="comment">// Got: the</span></span><br><span class="line"><span class="comment">// Got: thread</span></span><br><span class="line"><span class="comment">// Got: you</span></span><br></pre></td></tr></table></figure>
<h3 id="16-3-shared-state-concurrency">16-3 Shared-State Concurrency</h3>
<p>Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time.</p>
<h4 id="16-3-1-using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time">16-3-1 Using Mutexes to Allow Access to Data from One Thread at a Time</h4>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in, a mutex allows only one thread to access some data at any given time. To access the data in a mutex, a thread must first signal that it wants access by asking to acquire the mutex’s <em>lock</em>.</p>
<p>Management of mutexes can be incredibly tricky to get right (lock and unlock), which is why so many people are enthusiastic about channels. However, thanks to Rust’s type system and ownership rules, you can’t get locking and unlocking wrong.</p>
<h5 id="16-3-1-1-the-api-of-mutex-t">16-3-1-1 The API of <code>Mutex&lt;T&gt;</code></h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// m = 6</span></span><br></pre></td></tr></table></figure>
<p><code>lock</code> call will block the current thread so it can’t do any work until it’s our turn to have the lock. The call to <code>lock</code> would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we’ve chosen to <code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p><code>Mutex</code> is a smart pointer. More accurately, the call to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a <code>LockResult</code> that we handled with the call to <code>unwrap</code>.</p>
<p>The <code>MutexGuard</code> smart pointer implements <code>Deref</code> to point at our inner data; the smart pointer also has a <code>Drop</code> implementation that releases the lock automatically when a <code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope.</p>
<h5 id="16-3-1-2-sharing-a-mutex-t-between-multiple-threads">16-3-1-2 Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> counter = Mutex::new(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handle = <span class="built_in">vec!</span>[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">		hundles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">    	handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result:&#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0382]: capture of moved value: `counter`</span></span><br></pre></td></tr></table></figure>
<p>The <code>counter</code> value is moved into the closure and then captured when we call <code>lock</code>. That description sounds like what we wanted, but it’s not allowed!</p>
<p>We can’t move ownership of <code>counter</code> into multiple threads. This was hard to see because our threads were in a loop, and Rust can’t point to different threads in different iterations of the loop.</p>
<h5 id="16-3-1-3-multiple-ownership-with-multiple-threads">16-3-1-3 Multiple Ownership with Multiple Threads</h5>
<p>We’ll wrap the <code>Mutex</code> in <code>Rc</code> and clone the <code>Rc</code> before moving ownership to the thread.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">let</span> counter = Rc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    	<span class="keyword">let</span> counter = Rc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        	<span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">    	handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;: std::marker::Send` is not satisfied</span></span><br></pre></td></tr></table></figure>
<p><code>Rc</code> is not safe to share across threads. When <code>Rc</code> manages the reference count, it adds to the count for each call to <code>clone</code> and subtracts from the count when each clone is dropped. But it doesn’t use any concurrency primitives to make sure that changes to the count can’t be interrupted by another thread. This could lead to wrong counts—subtle bugs that could in turn lead to memory leaks or a value being dropped before we’re done with it. What we need is a type exactly like <code>Rc</code> but one that makes changes to the reference count in a thread-safe way.</p>
<h5 id="16-3-1-4-atomic-reference-counting-with-arc-t">16-3-1-4 Atomic Reference Counting with <code>Arc&lt;T&gt;</code></h5>
<p><code>Arc</code> <em>is</em> a type like <code>Rc</code> that is safe to use in concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically reference counted</em> type. Atomics work like primitive types but are safe to share across threads.</p>
<p>Why all primitive types aren’t atomic and why standard library types aren’t implemented to use <code>Arc</code> by default? The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Mutex, Arc&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line"></span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Result: 10</span></span><br></pre></td></tr></table></figure>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/arc" target="_blank" rel="noopener">here</a>.</p>
<h4 id="16-3-2-similarities-between-refcell-t-rc-t-and-mutex-t-arc-t">16-3-2 Similarities Between <code>RefCell&lt;T&gt;/Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;/Arc&lt;T&gt;</code></h4>
<p><code>counter</code> is immutable but we could get a mutable reference to the value inside it, <code>Mutex</code> provides interior mutability, as the <code>Cell</code> family does.</p>
<ul>
<li>We use <code>RefCell</code> to allow us to mutate contents inside an <code>Rc</code></li>
<li>We use <code>Mutex</code> to mutate contents inside an <code>Arc</code>.</li>
</ul>
<p>Rust can’t protect you from all kinds of logic errors when you use <code>Mutex</code>.</p>
<ul>
<li>using <code>Rc</code> came with the risk of creating reference cycles, where two <code>Rc</code> values refer to each other, causing memory leaks.</li>
<li><code>Mutex</code> comes with the risk of creating <em>deadlocks</em>. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever.</li>
</ul>
<h3 id="16-4-extensible-concurrency-with-the-sync-and-send-traits">16-4 Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</h3>
<p>Rust language has <em>very</em> few concurrency features. Almost every concurrency feature we’ve talked about so far in this chapter has been part of the standard library, not the language. However, two concurrency concepts are embedded in the language: the <code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<h4 id="16-4-1-allowing-transference-of-ownership-between-threads-with-send">16-4-1 Allowing Transference of Ownership Between Threads with <code>Send</code></h4>
<p>The <code>Send</code> marker trait indicates that ownership of the type implementing <code>Send</code> can be transferred between threads. Almost every Rust type is <code>Send</code>, but there are some exceptions, including <code>Rc</code>: this cannot be <code>Send</code> because if you cloned an <code>Rc</code> value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, <code>Rc</code> is implemented for use in single-threaded situations where you don’t want to pay the thread-safe performance penalty.</p>
<h4 id="16-4-2-allowing-access-from-multiple-threads-with-sync">16-4-2 Allowing Access from Multiple Threads with <code>Sync</code></h4>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing <code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is <code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>, meaning the reference can be sent safely to another thread. Similar to <code>Send</code>, primitive types are <code>Sync</code>, and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc</code> is also not <code>Sync</code> for the same reasons that it’s not <code>Send</code>. The <code>RefCell</code> type and the family of related <code>Cell</code> types are not <code>Sync</code>. The smart pointer <code>Mutex</code> is <code>Sync</code> and can be used to share access with multiple threads.</p>
<h4 id="16-4-3-implementing-send-and-sync-manually-is-unsafe">16-4-3 Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</h4>
<p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically also <code>Send</code> and <code>Sync</code>, we don’t have to implement those traits manually. Building new concurrent types not made up of <code>Send</code> and <code>Sync</code> parts requires careful thought to uphold the safety guarantees.</p>
<h2 id="19-advanced-features">19 Advanced Features</h2>
<h3 id="19-1-unsafe-rust">19-1 Unsafe Rust</h3>
<p>One reason is static analysis is conservative; Another is that the underlying computer hardware is inherently unsafe.</p>
<h4 id="19-1-1-unsafe-superpowers">19-1-1 Unsafe Superpowers</h4>
<p><code>unsafe</code> doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked.</p>
<p>The <code>unsafe</code> keyword only gives you access to these four features that are then not checked by the compiler for memory safety.</p>
<p><code>unsafe</code> does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems. You’ll ensure the code inside an <code>unsafe</code> block will access memory in a valid way.</p>
<h4 id="19-1-2-dereferencing-a-raw-pointer">19-1-2 Dereferencing a Raw Pointer</h4>
<p>Unsafe Rust has two new types called <em>raw pointers</em> that are similar to references. As with references, raw pointers can be immutable or mutable and are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the dereference operator; it’s part of the type name. In the context of raw pointers, <em>immutable</em> means that the pointer can’t be directly assigned to after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<p>Give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>How to create an immutable and a mutable raw pointer from references:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br></pre></td></tr></table></figure>
<p>We can create raw pointers in safe code (don’t include <code>unsafe</code>); we just can’t dereference raw pointers outside an unsafe block.</p>
<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br></pre></td></tr></table></figure>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em> raw pointers and read the data being pointed to. We use the dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line"><span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"r1 is: &#123;&#125;"</span>, *r1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"r2 is: &#123;&#125;"</span>, *r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Creating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.</p>
<p>Normally, if we create an immutable and a mutable reference to <code>num</code>, the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race.</p>
<p>Why would you ever use raw pointers?</p>
<ul>
<li>One major use case is when interfacing with C code</li>
<li>Another is when building up safe abstractions that the borrow checker doesn’t understand</li>
</ul>
<h4 id="19-1-3-calling-an-unsafe-function-or-method">19-1-3 Calling an Unsafe Function or Method</h4>
<p>The <code>unsafe</code> keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">	dangerous();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// without unsafe, error[E0133]: call to unsafe function requires unsafe function or block</span></span><br></pre></td></tr></table></figure>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other unsafe operations within an unsafe function, we don’t need to add another <code>unsafe</code> block.</p>
<h5 id="19-1-3-1-creating-a-safe-abstraction-over-unsafe-code">19-1-3-1 Creating a Safe Abstraction over Unsafe Code</h5>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split_at_mut usage</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> (a, b) = r.split_at_mut(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br></pre></td></tr></table></figure>
<p>We can’t implement this function using only safe Rust.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid],</span><br><span class="line">     &amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0499]: cannot borrow `*slice` as mutable more than once at a time</span></span><br></pre></td></tr></table></figure>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line">    <span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">         slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="built_in">isize</span>), len - mid))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code> method to access the raw pointer of a slice. In this case, because we have a mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type <code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>
<p>The <code>slice::from_raw_parts_mut</code> function takes a raw pointer and a length, and it creates a slice. Then we call the <code>offset</code> method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at <code>mid</code>.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw pointer and must trust that this pointer is valid. The <code>offset</code> method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer.</p>
<p>By looking at the code and by adding the assertion that <code>mid</code> must be less than or equal to <code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block will be valid pointers to data within the slice.</p>
<p>This is an acceptable and appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as <code>unsafe</code>, and we can call this function from safe Rust.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MAY CRASH</span></span><br><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> address = <span class="number">0x01234usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    slice::from_raw_parts_mut(r, <span class="number">10000</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid <code>i32</code> values. Attempting to use <code>slice</code> as though it’s a valid slice results in undefined behavior.</p>
<h5 id="19-1-3-2-using-extern-functions-to-call-external-code">19-1-3-2 Using <code>extern</code> Functions to Call External Code</h5>
<p>Functions declared within <code>extern</code> blocks are always unsafe to call from Rust code. The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="keyword">unsafe</span> &#123;</span><br><span class="line">    	<span class="built_in">println!</span>(<span class="string">"Absolute value of -3 according to C: &#123;&#125;"</span>, abs(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-1-4-accessing-or-modifying-a-mutable-static-variable">19-1-4 Accessing or Modifying a Mutable Static Variable</h4>
<p>In Rust, global variables are called <em>static</em> variables.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="built_in">str</span> = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="built_in">println!</span>(<span class="string">"name is: &#123;&#125;"</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The names of static variables are in <code>SCREAMING_SNAKE_CASE</code> by convention, and we <em>must</em> annotate the variable’s type, which is <code>&amp;'static str</code> in this example. Static variables can only store references with the <code>'static</code> lifetime, which means the Rust compiler can figure out the lifetime; we don’t need to annotate it explicitly. Accessing an immutable static variable is safe.</p>
<p>Difference between constants and immutable static variables:</p>
<ul>
<li>Values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used.</li>
<li>Static variables can be mutable. Accessing and modifying mutable static variables is <em>unsafe</em>.</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"COUNTER: &#123;&#125;"</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Any code that reads or writes from <code>mut COUNTER</code> must be within an <code>unsafe</code> block.</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.</p>
<h4 id="19-1-5-implementing-an-unsafe-trait">19-1-5 Implementing an Unsafe Trait</h4>
<p>A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="comment">// methods go here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// method implementations go here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that the compiler can’t verify.</p>
<h3 id="19-2-advanced-traits">19-2 Advanced Traits</h3>
<h4 id="19-2-1-specifying-placeholder-types-in-trait-definitions-with-associated-types">19-2-1 Specifying Placeholder Types in Trait Definitions with Associated Types</h4>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The type <code>Item</code> is a placeholder type, and the <code>next</code> method’s definition shows that it will return values of type <code>Option</code>. Implementors of the <code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code> method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. So why use associated types?</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">	<span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Generics:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The difference is that when using generics, we must annotate the types in each implementation; because we can also implement <code>Iterator for Counter</code> or any other type, we could have multiple implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the <code>next</code> method on <code>Counter</code>, we would have to provide type annotations to indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. With the definition that uses associated types, we can only choose what the type of <code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>. We don’t have to specify that we want an iterator of <code>u32</code> values everywhere that we call <code>next</code> on <code>Counter</code>.</p>
<h4 id="19-2-2-default-generic-type-parameters-and-operator-overloading">19-2-2 Default Generic Type  Parameters and Operator Overloading</h4>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. The syntax for specifying a default type for a generic type is <code>&lt;PlaceholderType=ConcreteType&gt;</code> when declaring the generic type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug, PartialEq)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Point;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Point) -&gt; Point &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x + other.x,</span><br><span class="line">            y: <span class="keyword">self</span>.y + other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125; + Point &#123; x: <span class="number">2</span>, y: <span class="number">3</span> &#125;,</span><br><span class="line">               Point &#123; x: <span class="number">3</span>, y: <span class="number">3</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its definition:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;RHS=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: RHS) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RHS=Self</code> is called <em>default type parameters</em>. The <code>RHS</code> generic type parameter (short for “right hand side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t specify a concrete type for <code>RHS</code> when we implement the <code>Add</code> trait, the type of <code>RHS</code> will default to <code>Self</code>, which will be the type we’re implementing <code>Add</code> on.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Millimeters</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meters</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add&lt;Meters&gt; <span class="keyword">for</span> Millimeters &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Meters) -&gt; Millimeters &#123;</span><br><span class="line">        Millimeters(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add</code> to set the value of the <code>RHS</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>Two ways to use default type parameters:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ul>
<p>The first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.</p>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose: usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to customize beyond that. Using a default type parameter in the <code>Add</code> trait definition means you don’t have to specify the extra parameter most of the time.</p>
<h4 id="19-2-3-fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">19-2-3 Fully Qualified Syntax for Disambiguation, Calling Methods with the Same Name</h4>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Pilot</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Wizard</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Human</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Pilot <span class="keyword">for</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"This is your captain speaking."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Wizard <span class="keyword">for</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Up!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Human &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fly</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"*waving arms furiously*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> person = Human;</span><br><span class="line">    person.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// *waving arms furiously*</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> person = Human;</span><br><span class="line">    Pilot::fly(&amp;person);</span><br><span class="line">    Wizard::fly(&amp;person);</span><br><span class="line">    person.fly();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// This is your captain speaking.</span></span><br><span class="line"><span class="comment">// Up!</span></span><br><span class="line"><span class="comment">// *waving arms furiously*</span></span><br></pre></td></tr></table></figure>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that both implement one <em>trait</em>, Rust could figure out which implementation of a trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are part of traits don’t have a <code>self</code> parameter. When two types in the same scope implement that trait, Rust can’t figure out which type you mean unless you use <em>fully qualified syntax</em>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Animal</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Dog</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Dog &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"Spot"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Animal <span class="keyword">for</span> Dog &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">baby_name</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"puppy"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"A baby dog is called a &#123;&#125;"</span>, Dog::baby_name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A baby dog is called a Spot</span></span><br></pre></td></tr></table></figure>
<p>We want <code>A baby dog is called a puppy</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"A baby dog is called a &#123;&#125;"</span>, Animal::baby_name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0283]: type annotations required: cannot resolve `_: Animal`</span></span><br></pre></td></tr></table></figure>
<p>Because <code>Animal::baby_name</code> is an associated function rather than a method, and thus doesn’t have a <code>self</code> parameter, Rust can’t figure out which implementation of <code>Animal::baby_name</code> we want.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"A baby dog is called a &#123;&#125;"</span>, &lt;Dog <span class="keyword">as</span> Animal&gt;::baby_name());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// A baby dog is called a puppy</span></span><br></pre></td></tr></table></figure>
<p>In general, fully qualified syntax is defined as follows:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Type <span class="keyword">as</span> Trait&gt;::function(receiver_if_method, next_arg, ...);</span><br></pre></td></tr></table></figure>
<p>For associated functions, there would not be a <code>receiver</code>: there would only be the list of other arguments.</p>
<p>You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.</p>
<h4 id="19-2-4-using-supertraits-to-require-one-trait-s-functionality-within-another-trait">19-2-4 Using Supertraits to Require One Trait’s Functionality Within Another Trait</h4>
<p>Sometimes, you might need one trait to use another trait’s functionality. In this case, you need to rely on the dependent trait also being implemented. The trait you rely on is a <em>supertrait</em> of the trait you’re implementing.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">OutlinePrint</span></span>: fmt::Display &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">outline_print</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="keyword">self</span>.to_string();</span><br><span class="line">        <span class="keyword">let</span> len = output.len();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">"*"</span>.repeat(len + <span class="number">4</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"*&#123;&#125;*"</span>, <span class="string">" "</span>.repeat(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"* &#123;&#125; *"</span>, output);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"*&#123;&#125;*"</span>, <span class="string">" "</span>.repeat(len + <span class="number">2</span>));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, <span class="string">"*"</span>.repeat(len + <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we can use the <code>to_string</code> function that is automatically implemented for any type that implements <code>Display</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> OutlinePrint <span class="keyword">for</span> Point &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>When we try to implement <code>OutlinePrint</code> on a type that doesn’t implement <code>Display</code>, We get an error saying that <code>Display</code> is required but not implemented.</p>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that <code>OutlinePrint</code> requires:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Point &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">"(&#123;&#125;, &#123;&#125;)"</span>, <span class="keyword">self</span>.x, <span class="keyword">self</span>.y)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="19-2-5-using-the-newtype-pattern-to-implement-external-traits-on-external-types">19-2-5 Using the Newtype Pattern to Implement External Traits on External Types</h4>
<p>In Chapter 10 in the <a href="https://doc.rust-lang.org/stable/book/ch10-02-traits.html#implementing-a-trait-on-a-type" target="_blank" rel="noopener">“Implementing a Trait on a Type”</a> section, we mentioned the orphan rule that states we’re allowed to implement a trait on a type as long as either the trait or the type are local to our crate. It’s possible to get around this restriction using the <em>newtype pattern</em>, which involves creating a new type in a tuple struct.</p>
<p><em>Newtype</em> is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec</code>, which the orphan rule prevents us from doing directly because the <code>Display</code> trait and the <code>Vec</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct that holds an instance of <code>Vec</code>; then we can implement <code>Display</code> on <code>Wrapper</code> and use the <code>Vec</code> value.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Wrapper</span></span>(<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::Display <span class="keyword">for</span> Wrapper &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> fmt::Formatter) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        <span class="built_in">write!</span>(f, <span class="string">"[&#123;&#125;]"</span>, <span class="keyword">self</span>.<span class="number">0</span>.join(<span class="string">", "</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> w = Wrapper(<span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"hello"</span>), <span class="built_in">String</span>::from(<span class="string">"world"</span>)]);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"w = &#123;&#125;"</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec</code>, because <code>Wrapper</code> is a tuple struct and <code>Vec</code> is the item at index 0 in the tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it doesn’t have the methods of the value it’s holding. We would have to implement all the methods of <code>Vec</code> directly on <code>Wrapper</code> such that the methods delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a <code>Vec</code>. If we wanted the new type to have every method the inner type has, implementing the <code>Deref</code> trait on the <code>Wrapper</code> to return the inner type would be a solution.</p>
<p>If we don’t want the <code>Wrapper</code> type to have all the methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s behavior—we would have to implement just the methods we do want manually.</p>
<h3 id="19-3-advanced-types">19-3 Advanced Types</h3>
<h4 id="19-3-1-using-the-newtype-pattern-for-type-safety-and-abstraction">19-3-1 Using the Newtype Pattern for Type Safety and Abstraction</h4>
<p>The newtype pattern is useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value.</p>
<p>Another use of the newtype pattern is in abstracting away some implementation details of a type.</p>
<h4 id="19-3-2-creating-type-synonyms-with-type-aliases">19-3-2 Creating Type Synonyms with Type Aliases</h4>
<p>Along with the newtype pattern, Rust provides the ability to declare a <em>type alias</em> to give an existing type another name.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Kilometers</span></span> = <span class="built_in">i32</span>;</span><br></pre></td></tr></table></figure>
<p>The alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>, it is not a separate, new type.</p>
<p>Using this method, we don’t get the type checking benefits that we get from the newtype pattern discussed earlier.</p>
<p>The main use case for type synonyms is to reduce repetition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt; = <span class="built_in">Box</span>::new(|| <span class="built_in">println!</span>(<span class="string">"hi"</span>));</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_long_type</span></span>(f: <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Thunk</span></span> = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> f: Thunk = <span class="built_in">Box</span>::new(|| <span class="built_in">println!</span>(<span class="string">"hi"</span>));</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_long_type</span></span>(f: Thunk) &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Type aliases are also commonly used with the <code>Result</code> type for reducing repetition.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::io::Error;</span><br><span class="line"><span class="keyword">use</span> std::fmt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Write</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">usize</span>, Error&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flush</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_all</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_fmt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: fmt::Arguments) -&gt; <span class="built_in">Result</span>&lt;(), Error&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// E filled in as std::io::Error</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;T&gt; = std::result::<span class="built_in">Result</span>&lt;T, std::io::Error&gt;;</span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Write</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">usize</span>&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">flush</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_all</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, buf: &amp;[<span class="built_in">u8</span>]) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">write_fmt</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fmt: Arguments) -&gt; <span class="built_in">Result</span>&lt;()&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Because it’s an alias, it’s just another <code>Result</code>, which means we can use any methods that work on <code>Result</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h4 id="19-3-3-the-never-type-that-never-returns">19-3-3 The Never Type that Never Returns</h4>
<p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the <em>empty type</em> because it has no values. We prefer to call it the <em>never type</em> because it stands in the place of the return type when a function will never return.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">bar</span></span>() -&gt; ! &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Functions that return never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code> so <code>bar</code> can never possibly return.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> guess: <span class="built_in">u32</span> = <span class="keyword">match</span> guess.trim().parse() &#123;</span><br><span class="line">    <span class="literal">Ok</span>(num) =&gt; num,</span><br><span class="line">    <span class="literal">Err</span>(_) =&gt; <span class="keyword">continue</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>match</code> arms must all return the same type, <code>continue</code> has a <code>!</code> value. Because <code>!</code> can never have a value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The never type is useful with the <code>panic!</code> macro as well.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span>&lt;T&gt; <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unwrap</span></span>(<span class="keyword">self</span>) -&gt; T &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="literal">Some</span>(val) =&gt; val,</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="built_in">panic!</span>(<span class="string">"called `Option::unwrap()` on a `None` value"</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rust sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>.</p>
<h4 id="19-3-4-dynamically-sized-types-and-the-sized-trait">19-3-4 Dynamically Sized Types and the <code>Sized</code> Trait</h4>
<p><em>dynamically sized types</em>. sometimes referred to as <em>DSTs</em> or <em>unsized types</em>, these types let us write code using values whose size we can know only at runtime.</p>
<p><code>str</code> on its own, is a DST. We can’t know how long the string is until runtime, meaning we can’t create a variable of type <code>str</code>, nor can we take an argument of type <code>str</code>.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// does not work</span></span><br><span class="line"><span class="keyword">let</span> s1: <span class="built_in">str</span> = <span class="string">"Hello there!"</span>;</span><br><span class="line"><span class="keyword">let</span> s2: <span class="built_in">str</span> = <span class="string">"How's it going?"</span>;</span><br></pre></td></tr></table></figure>
<p>Rust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory. If Rust allowed us to write this code, these two <code>str</code> values would need to take up the same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of storage and <code>s2</code> needs 15. This is why it’s not possible to create a variable holding a dynamically sized type.</p>
<p>We make the types of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. The slice data structure stores the starting position and the length of the slice. So although a <code>&amp;T</code> is a single value that stores the memory address of where the <code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its length. The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.</p>
<p>Rust has a particular trait called the <code>Sized</code> trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T&gt;(t: T) &#123;&#125;</span><br><span class="line"><span class="comment">// is treated as though we had written</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T: <span class="built_in">Sized</span>&gt;(t: T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>By default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">generic</span></span>&lt;T: ?<span class="built_in">Sized</span>&gt;(t: &amp;T) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>We would read this as “<code>T</code> may or may not be <code>Sized</code>.” This syntax is only available for <code>Sized</code>, not any other traits.</p>
<h3 id="19-4-advanced-functions-and-closures">19-4 Advanced Functions and Closures</h3>
<h4 id="19-4-1-function-pointers">19-4-1 Function Pointers</h4>
<p>Functions coerce to the type <code>fn</code> (with a lowercase f), not to be confused with the <code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function pointer</em>. The syntax for specifying that a parameter is a function pointer is similar to that of closures.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">do_twice</span></span>(f: <span class="function"><span class="keyword">fn</span></span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>, arg: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    f(arg) + f(arg)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> answer = do_twice(add_one, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The answer is: &#123;&#125;"</span>, answer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the parameter type directly rather than declaring a generic type parameter with one of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>), so you can always pass a function pointer as an argument for a function that expects a closure.</p>
<p>It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.</p>
<p>An example of where you would want to only accept <code>fn</code> and not closures is when interfacing with external code that doesn’t have closures: C functions can accept functions as arguments, but C doesn’t have closures.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list_of_numbers = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list_of_strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(|i| i.to_string()) <span class="comment">// closure</span></span><br><span class="line">    .collect();</span><br></pre></td></tr></table></figure>
<p>Or name a function as the argument to <code>map</code> instead of the closure:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list_of_numbers = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list_of_strings: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = list_of_numbers</span><br><span class="line">    .iter()</span><br><span class="line">    .map(<span class="built_in">ToString</span>::to_string) <span class="comment">// named function</span></span><br><span class="line">    .collect();</span><br></pre></td></tr></table></figure>
<p>We have another useful pattern that exploits an implementation detail of tuple structs and tuple-struct enum variants.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Status</span></span> &#123;</span><br><span class="line">    Value(<span class="built_in">u32</span>),</span><br><span class="line">    Stop,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list_of_statuses: <span class="built_in">Vec</span>&lt;Status&gt; =</span><br><span class="line">    (<span class="number">0u32</span>..<span class="number">20</span>)</span><br><span class="line">    .map(Status::Value)</span><br><span class="line">    .collect();</span><br></pre></td></tr></table></figure>
<p>Here we create <code>Status::Value</code> instances using each <code>u32</code> value in the range that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.</p>
<h4 id="19-4-2-returning-closures">19-4-2 Returning Closures</h4>
<p>Closures are represented by traits, which means you can’t return closures directly. In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function. But you can’t do that with closures because they don’t have a concrete type that is returnable; you’re not allowed to use the function pointer <code>fn</code> as a return type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_closure</span></span>() -&gt; <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">	|x| x + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static: std::marker::Sized` is not satisfied</span></span><br></pre></td></tr></table></figure>
<p>The error references the <code>Sized</code> trait again! Rust doesn’t know how much space it will need to store the closure.</p>
<p>We can use a trait object:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">returns_closure</span></span>() -&gt; <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">Fn</span>(<span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    	<span class="built_in">Box</span>::new(|x| x+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="19-5-macros">19-5 Macros</h3>
<p>The term <em>macro</em> refers to a family of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds of <em>procedural</em> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens specified as their argument</li>
</ul>
<h4 id="19-5-1-the-difference-between-macros-and-functions">19-5-1 The Difference Between Macros and Functions</h4>
<p>Fundamentally, macros are a way of writing code that writes other code, which is known as <em>metaprogramming</em>. Metaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.</p>
<ul>
<li>A function signature must declare the number and type of parameters the function has. Macros can take a variable number of parameters.</li>
<li>Macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.</li>
<li>The downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code.</li>
<li>You must define macros or bring them into scope <em>before</em> you call them in a file, as opposed to functions you can define anywhere and call anywhere.</li>
</ul>
<h4 id="19-5-2-declarative-macros-with-macro-rules-for-general-metaprogramming">19-5-2 Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</h4>
<p>The most widely used form of macros in Rust is <em>declarative macros</em>, which allow you to write something similar to a Rust <code>match</code> expression.</p>
<p>Like <code>match</code>, macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> v: <span class="built_in">Vec</span>&lt;<span class="built_in">u32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,];</span><br></pre></td></tr></table></figure>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector of five string slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_export]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> vec &#123;</span><br><span class="line">    ( $( $x:expr ),* ) =&gt; &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">            $(</span><br><span class="line">                temp_vec.push($x);</span><br><span class="line">            )*</span><br><span class="line">            temp_vec</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.</p>
<p>First, a set of parentheses encompasses the whole pattern. A dollar sign (<code>$</code>) is next, followed by a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within <code>$()</code> is <code>$x:expr</code>, which matches any Rust expression and gives the expression the name <code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character could optionally appear after the code that matches the code in <code>$()</code>. The <code>*</code> specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p><code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code> in the pattern zero or more times depending on how many times the pattern matches. The <code>$x</code> is replaced with each expression matched.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> temp_vec = <span class="built_in">Vec</span>::new();</span><br><span class="line">temp_vec.push(<span class="number">1</span>);</span><br><span class="line">temp_vec.push(<span class="number">2</span>);</span><br><span class="line">temp_vec.push(<span class="number">3</span>);</span><br><span class="line">temp_vec</span><br></pre></td></tr></table></figure>
<h4 id="19-5-3-procedural-macros-for-generating-code-from-attributes">19-5-3 Procedural Macros for Generating Code from Attributes</h4>
<p>The second form of macros is <em>procedural macros</em>, which act more like functions (and are a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do.</p>
<p>The three kinds of procedural macros (custom derive, attribute-like, and function-like) all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate with a special crate type.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[some_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">some_name</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>TokenStream</code> type is defined by the <code>proc_macro</code> crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input <code>TokenStream</code>, and the code the macro produces is the output <code>TokenStream</code>.</p>
<h4 id="19-5-4-how-to-write-a-custom-derive-macro">19-5-4 How to Write a Custom <code>derive</code> Macro</h4>
<p>We’ll provide a procedural macro so users can annotate their type with <code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code> function.</p>
<p>Filename: <code>src/main.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"><span class="keyword">use</span> hello_macro_derive::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(HelloMacro)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pancakes</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    Pancakes::hello_macro();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done.</p>
<p>Step1: make a new library crate: <code>$ cargo new hello_macro --lib</code></p>
<p>Step2: define the <code>HelloMacro</code> trait and its associated function</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">HelloMacro</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here crate user could implement the trait to achieve the desired functionality:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> hello_macro::HelloMacro;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pancakes</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> HelloMacro <span class="keyword">for</span> Pancakes &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Hello, Macro! My name is Pancakes!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    Pancakes::hello_macro();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, they would need to write the implementation block for each type they wanted to use with <code>hello_macro</code>.</p>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate code at compile time.</p>
<p>Step3: define the procedural macro</p>
<p>Procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is called <code>foo_derive</code>. Start a new crate <code>hello_macro_derive</code> inside <code>hello_macro</code>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new hello_macro_derive --lib</span><br></pre></td></tr></table></figure>
<p>The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope.</p>
<p>We could instead have the <code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the procedural macro code. However, the way we’ve structured the project makes it possible for programmers to use <code>hello_macro</code> even if they don’t want the <code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate. We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, so we need to add them as dependencies.</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">syn</span> = <span class="string">"0.14.4"</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">"0.6.3"</span></span><br></pre></td></tr></table></figure>
<p>Filename: <code>hello_macro_derive/src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"><span class="keyword">use</span> syn;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_derive(HelloMacro)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro_derive</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="comment">// Construct a representation of Rust code as a syntax tree</span></span><br><span class="line">    <span class="comment">// that we can manipulate</span></span><br><span class="line">    <span class="keyword">let</span> ast = syn::parse(input).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build the trait implementation</span></span><br><span class="line">    impl_hello_macro(&amp;ast)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API that allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back into Rust code.</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and specified the name, <code>HelloMacro</code>, which matches our trait name; this is the convention most procedural macros follow.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a <code>TokenStream</code> to a data structure that we can then interpret and perform operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in <code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the parsed Rust code.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DeriveInput get from parsing the struct Pancakes;</span></span><br><span class="line">DeriveInput &#123;</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line"></span><br><span class="line">    ident: Ident &#123;</span><br><span class="line">        ident: <span class="string">"Pancakes"</span>,</span><br><span class="line">        span: #<span class="number">0</span> bytes(<span class="number">95</span>..<span class="number">103</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    data: Struct(</span><br><span class="line">        DataStruct &#123;</span><br><span class="line">            struct_token: Struct,</span><br><span class="line">            fields: Unit,</span><br><span class="line">            semi_token: <span class="literal">Some</span>(</span><br><span class="line">                Semi</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’re calling <code>unwrap</code> to cause the <code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function fails here. It’s necessary for our procedural macro to panic on errors because <code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to conform to the procedural macro API. We’ve simplified this example by using <code>unwrap</code>; in production code, you should provide more specific error messages about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code> into a <code>DeriveInput</code> instance.</p>
<p>Filename: <code>hello_macro_derive/src/lib.rs</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">impl_hello_macro</span></span>(ast: &amp;syn::DeriveInput) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> name = &amp;ast.ident;</span><br><span class="line">    <span class="keyword">let</span> gen = quote! &#123;</span><br><span class="line">        <span class="keyword">impl</span> HelloMacro <span class="keyword">for</span> #name &#123;</span><br><span class="line">            <span class="function"><span class="keyword">fn</span> <span class="title">hello_macro</span></span>() &#123;</span><br><span class="line">                <span class="built_in">println!</span>(<span class="string">"Hello, Macro! My name is &#123;&#125;"</span>, <span class="built_in">stringify!</span>(#name));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    gen.into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>name</code> variable will contain an <code>Ident</code> struct instance that, when printed, will be the string <code>&quot;Pancakes&quot;</code>.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the <code>quote!</code> macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by calling the <code>into</code> method, which consumes this intermediate representation and returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust expression, such as <code>1 + 2</code>, and at compile time turns the expression into a string literal, such as <code>&quot;1 + 2&quot;</code>. Macros evaluate the expression and then turn the result into a <code>String</code>. There is a possibility that the <code>#name</code> input might be an expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code> and <code>hello_macro_derive</code>. Create a new binary project  <code>cargo new pancakes</code>. Add <code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies. If publishing  to <a href="https://crates.io/" target="_blank" rel="noopener">crates.io</a>, they would be regular dependencies; if not, specify them as <code>path</code> dependencies:</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">hello_macro</span> = &#123; path = <span class="string">"../hello_macro"</span> &#125;</span><br><span class="line"><span class="attr">hello_macro_derive</span> = &#123; path = <span class="string">"../hello_macro/hello_macro_derive"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>With the code <em>src/main.rs</em>, run <code>cargo run</code>: it should print <code>Hello, Macro! My name is Pancakes!</code></p>
<p>The code can be found <a href="https://github.com/hscspring/Coding-Collections/tree/master/Rust/custommacro/" target="_blank" rel="noopener">here</a>.</p>
<h4 id="19-5-5-attribute-like-macros">19-5-5 Attribute-like macros</h4>
<p>Attribute-like macros are similar to custom derive macros, but instead of generating code for the <code>derive</code> attribute, they allow you to create new attributes. They’re also more flexible: <code>derive</code> only works for structs and enums; attributes can be applied to other items as well, such as functions.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[route(GET, <span class="meta-string">"/"</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the contents of the attribute: the <code>GET, &quot;/&quot;</code> part. The second is the body of the item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest of the function’s body.</p>
<h4 id="19-5-6-function-like-macros">19-5-6 Function-like macros</h4>
<p>Function-like macros define macros that look like function calls. <code>macro_rules!</code> macros can be defined only using the match-like syntax. Function-like macros take a <code>TokenStream</code> parameter and their definition manipulates that <code>TokenStream</code> using Rust code as the other two types of procedural macros do.</p>
<p>An example of a function-like macro is an <code>sql!</code> macro that might be called like so:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sql = sql!(SELECT * FROM posts WHERE id=<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>This macro would parse the SQL statement inside it and check that it’s syntactically correct. The <code>sql!</code> macro would be defined like this:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">sql</span></span>(input: TokenStream) -&gt; TokenStream &#123;&#125;</span><br></pre></td></tr></table></figure>

      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol4-Advance/">
    <time datetime="2019-12-03T04:00:00.000Z" class="entry-date">
        2019-12-03
    </time>
</a>
    
  <span class="article-delim">&#8226;</span>
  <div class="article-category">
  <a class="article-category-link" href="/categories/Coding/">Coding</a>
  </div>

    
  <span class="article-delim">&#8226;</span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Rust/">Rust</a></li></ul>

    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
        <span class="nav-previous"><a href="/2019/12/03/Rust/RPL/2020-01-21-RPL-Brief-Note-Vol3-Style/" rel="prev"><span class="meta-nav">←</span> The Rust Programming Language Brief Note (Vol3-Style)</a></span>
    
    
        <span class="nav-next"><a href="/2019/12/03/Rust/RPL/2019-12-31-RPL-Brief-Note-Vol5-Project/" rel="next">The Rust Programming Language Brief Note (Vol5-Project) <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







<div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_fbook" data-cmd="fbook" title="分享到Facebook"></a><a href="#" class="bds_twi" data-cmd="twi" title="分享到Twitter"></a><a href="#" class="bds_linkedin" data-cmd="linkedin" title="分享到linkedin"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_douban" data-cmd="douban" title="分享到豆瓣网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a><a href="#" class="bds_evernotecn" data-cmd="evernotecn" title="分享到印象笔记"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{},"image":{"viewList":["fbook","twi","linkedin","qzone","tsina","douban","weixin","evernotecn"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'];</script>

<section id="comment">
  <!-- 评论代码 -->
  <div id="gitalk-container"></div>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
  <script src="https://cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
  <script>
  const gitalk = new Gitalk({
    clientID: '0eb512031083d6e7edfb',
    clientSecret: 'e830808995dd813ca26fed50573760963457da37',
    repo: 'hscspring.github.io',
    owner: 'hscspring',
    admin: ['hscspring'],
    id: md5(location.pathname),
    distractionFreeMode: false
  })
  gitalk.render('gitalk-container')
  </script>
  <!-- 评论代码已完成 -->
</section>

</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    
  <aside class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-content">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Coding/">Coding</a><span class="category-list-count">73</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Feeling/">Feeling</a><span class="category-list-count">148</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thinking/">Thinking</a><span class="category-list-count">37</span></li></ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Music</h3>
    <div class="widget-content">
      <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=541131&auto=0&height=66"></iframe>
      <!-- 评论代码 -->
      <!-- <audio src="http://qnimg.lovevivian.cn/miss.mp3" controls="controls"
             style="width:100%">
        您的浏览器不支持 audio 标签。
      </audio> -->
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2025/07/27/NLP/LLM-DM/2025-07-27-Context-Engineering-and-Data/">重识LLM法则：上下文工程与数据进化</a>
          </li>
        
          <li>
            <a href="/2025/07/25/NLP/LLM-Training/2025-07-25-GiGPO/">GiGPO：双层级优势函数驱动的Agent强化学习新范式</a>
          </li>
        
          <li>
            <a href="/2025/07/13/NLP/LLM-Training/2025-07-13-RM-Data/">解锁模型潜能：Reward 数据如何塑造与激发 LLM 的推理策略</a>
          </li>
        
          <li>
            <a href="/2025/07/01/NLP/LLM-IF/2025-07-01-Activation-Steering/">激活诱导LLM指令跟随</a>
          </li>
        
          <li>
            <a href="/2025/06/26/Diary/2025-06-26-60hours-Pass-Arch-Exam/">60小时备考高架擦边过经验</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  <aside class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-content tagcloud">
      <a href="/tags/AE/" style="font-size: 10px;">AE</a> <a href="/tags/AI/" style="font-size: 19.33px;">AI</a> <a href="/tags/AIGC/" style="font-size: 10.67px;">AIGC</a> <a href="/tags/ALBERT/" style="font-size: 10px;">ALBERT</a> <a href="/tags/AR/" style="font-size: 10px;">AR</a> <a href="/tags/AUC/" style="font-size: 10px;">AUC</a> <a href="/tags/Accuracy/" style="font-size: 10px;">Accuracy</a> <a href="/tags/Activation/" style="font-size: 10px;">Activation</a> <a href="/tags/Activation-Steering/" style="font-size: 10px;">Activation Steering</a> <a href="/tags/Agent/" style="font-size: 10px;">Agent</a> <a href="/tags/Aha/" style="font-size: 10px;">Aha</a> <a href="/tags/Algorithm/" style="font-size: 12.67px;">Algorithm</a> <a href="/tags/Array/" style="font-size: 10px;">Array</a> <a href="/tags/Arrow/" style="font-size: 10px;">Arrow</a> <a href="/tags/Attention/" style="font-size: 12px;">Attention</a> <a href="/tags/Automatic-Speech-Processing/" style="font-size: 10px;">Automatic Speech Processing</a> <a href="/tags/Automation/" style="font-size: 10px;">Automation</a> <a href="/tags/BERT/" style="font-size: 16.67px;">BERT</a> <a href="/tags/BIO/" style="font-size: 10.67px;">BIO</a> <a href="/tags/BIOHD/" style="font-size: 10.67px;">BIOHD</a> <a href="/tags/BM25/" style="font-size: 10px;">BM25</a> <a href="/tags/BPE/" style="font-size: 10px;">BPE</a> <a href="/tags/BabyGrow/" style="font-size: 10px;">BabyGrow</a> <a href="/tags/Backtracking/" style="font-size: 10px;">Backtracking</a> <a href="/tags/Backward/" style="font-size: 10px;">Backward</a> <a href="/tags/Bahdanau-Attention/" style="font-size: 10px;">Bahdanau Attention</a> <a href="/tags/Bart/" style="font-size: 10px;">Bart</a> <a href="/tags/Bayes/" style="font-size: 10px;">Bayes</a> <a href="/tags/Beam-Search/" style="font-size: 10px;">Beam Search</a> <a href="/tags/Bert-Flow/" style="font-size: 10px;">Bert-Flow</a> <a href="/tags/Bi-LSTM/" style="font-size: 10px;">Bi-LSTM</a> <a href="/tags/Biasing/" style="font-size: 10px;">Biasing</a> <a href="/tags/BigCodec/" style="font-size: 10px;">BigCodec</a> <a href="/tags/Binary-Search/" style="font-size: 11.33px;">Binary Search</a> <a href="/tags/Blending/" style="font-size: 10px;">Blending</a> <a href="/tags/Brain/" style="font-size: 10px;">Brain</a> <a href="/tags/Brain-Decoding/" style="font-size: 10px;">Brain Decoding</a> <a href="/tags/Bridge/" style="font-size: 10px;">Bridge</a> <a href="/tags/Business/" style="font-size: 12px;">Business</a> <a href="/tags/C/" style="font-size: 10.67px;">C</a> <a href="/tags/C4/" style="font-size: 10px;">C4</a> <a href="/tags/CCG/" style="font-size: 10.67px;">CCG</a> <a href="/tags/CE-BERT/" style="font-size: 10px;">CE BERT</a> <a href="/tags/CFG/" style="font-size: 10px;">CFG</a> <a href="/tags/CISPO/" style="font-size: 10px;">CISPO</a> <a href="/tags/CKY/" style="font-size: 10px;">CKY</a> <a href="/tags/CNN/" style="font-size: 10px;">CNN</a> <a href="/tags/CRF/" style="font-size: 10px;">CRF</a> <a href="/tags/CS/" style="font-size: 10px;">CS</a> <a href="/tags/CYK/" style="font-size: 10px;">CYK</a> <a href="/tags/Calculus/" style="font-size: 10px;">Calculus</a> <a href="/tags/Camera/" style="font-size: 10px;">Camera</a> <a href="/tags/Cascades/" style="font-size: 10px;">Cascades</a> <a href="/tags/Catalan/" style="font-size: 10px;">Catalan</a> <a href="/tags/ChatBot/" style="font-size: 10px;">ChatBot</a> <a href="/tags/ChatGPT/" style="font-size: 15.33px;">ChatGPT</a> <a href="/tags/Chi2/" style="font-size: 10px;">Chi2</a> <a href="/tags/Chunking/" style="font-size: 10px;">Chunking</a> <a href="/tags/Class-Imbalance-Loss/" style="font-size: 10px;">Class Imbalance Loss</a> <a href="/tags/Classification/" style="font-size: 10.67px;">Classification</a> <a href="/tags/CoT/" style="font-size: 10px;">CoT</a> <a href="/tags/Codec/" style="font-size: 12px;">Codec</a> <a href="/tags/Cognition/" style="font-size: 10.67px;">Cognition</a> <a href="/tags/Collaborative-Filtering/" style="font-size: 10px;">Collaborative Filtering</a> <a href="/tags/Collins-Parser/" style="font-size: 10px;">Collins Parser</a> <a href="/tags/Computational-Linguistics/" style="font-size: 10px;">Computational Linguistics</a> <a href="/tags/Computer/" style="font-size: 10px;">Computer</a> <a href="/tags/Computer-Science/" style="font-size: 12px;">Computer Science</a> <a href="/tags/Confusing-Labels/" style="font-size: 10px;">Confusing Labels</a> <a href="/tags/Context-Engineering/" style="font-size: 10px;">Context Engineering</a> <a href="/tags/Context-Free-Grammars/" style="font-size: 10px;">Context-Free Grammars</a> <a href="/tags/Continual-Pre-training/" style="font-size: 14px;">Continual Pre-training</a> <a href="/tags/Continual-Pretraining/" style="font-size: 10.67px;">Continual Pretraining</a> <a href="/tags/Contrastive-Learning/" style="font-size: 10px;">Contrastive-Learning</a> <a href="/tags/Coordinate-Ascent/" style="font-size: 10px;">Coordinate Ascent</a> <a href="/tags/Cosine/" style="font-size: 10.67px;">Cosine</a> <a href="/tags/Cosine-Similarity/" style="font-size: 10px;">Cosine Similarity</a> <a href="/tags/Cross-Entropy/" style="font-size: 10px;">Cross Entropy</a> <a href="/tags/Cross-brackets/" style="font-size: 10px;">Cross-brackets</a> <a href="/tags/Cross-view/" style="font-size: 10px;">Cross-view</a> <a href="/tags/Ctrl/" style="font-size: 10px;">Ctrl</a> <a href="/tags/Culture/" style="font-size: 10px;">Culture</a> <a href="/tags/DA/" style="font-size: 10px;">DA</a> <a href="/tags/DAC/" style="font-size: 10px;">DAC</a> <a href="/tags/DAPO/" style="font-size: 12.67px;">DAPO</a> <a href="/tags/DB/" style="font-size: 10.67px;">DB</a> <a href="/tags/DNN/" style="font-size: 10px;">DNN</a> <a href="/tags/DP/" style="font-size: 10px;">DP</a> <a href="/tags/DPO/" style="font-size: 10px;">DPO</a> <a href="/tags/Data-Augmentation/" style="font-size: 10px;">Data Augmentation</a> <a href="/tags/Data-Clearing/" style="font-size: 10px;">Data Clearing</a> <a href="/tags/Data-Enhancement/" style="font-size: 10px;">Data Enhancement</a> <a href="/tags/Data-Preprocess/" style="font-size: 10px;">Data Preprocess</a> <a href="/tags/Data-Science/" style="font-size: 14px;">Data Science</a> <a href="/tags/Data-Structure/" style="font-size: 15.33px;">Data Structure</a> <a href="/tags/DataManagement/" style="font-size: 10.67px;">DataManagement</a> <a href="/tags/Database/" style="font-size: 10px;">Database</a> <a href="/tags/DeBERTa/" style="font-size: 10px;">DeBERTa</a> <a href="/tags/Debiasing/" style="font-size: 10px;">Debiasing</a> <a href="/tags/Decoder/" style="font-size: 10px;">Decoder</a> <a href="/tags/Decoding/" style="font-size: 10.67px;">Decoding</a> <a href="/tags/Deep/" style="font-size: 10px;">Deep</a> <a href="/tags/DeepGen/" style="font-size: 10px;">DeepGen</a> <a href="/tags/DeepGraph/" style="font-size: 10px;">DeepGraph</a> <a href="/tags/DeepLearning/" style="font-size: 12px;">DeepLearning</a> <a href="/tags/DeepScaleR/" style="font-size: 10.67px;">DeepScaleR</a> <a href="/tags/DeepSeek/" style="font-size: 10px;">DeepSeek</a> <a href="/tags/DeepSeek-GRM/" style="font-size: 10px;">DeepSeek-GRM</a> <a href="/tags/Dependence/" style="font-size: 10px;">Dependence</a> <a href="/tags/Diary/" style="font-size: 15.33px;">Diary</a> <a href="/tags/Disentangled-Attention/" style="font-size: 10px;">Disentangled Attention</a> <a href="/tags/DistilBERT/" style="font-size: 10px;">DistilBERT</a> <a href="/tags/Distillation/" style="font-size: 10.67px;">Distillation</a> <a href="/tags/Django/" style="font-size: 10px;">Django</a> <a href="/tags/Docker/" style="font-size: 10px;">Docker</a> <a href="/tags/Docker-Compose/" style="font-size: 10px;">Docker-Compose</a> <a href="/tags/Dockerfile/" style="font-size: 10px;">Dockerfile</a> <a href="/tags/Dr-GRPO/" style="font-size: 10px;">Dr GRPO</a> <a href="/tags/DrDAPO/" style="font-size: 10px;">DrDAPO</a> <a href="/tags/Dream/" style="font-size: 10.67px;">Dream</a> <a href="/tags/Dropout/" style="font-size: 10.67px;">Dropout</a> <a href="/tags/Dynamic-Mask/" style="font-size: 10px;">Dynamic-Mask</a> <a href="/tags/EDA/" style="font-size: 10px;">EDA</a> <a href="/tags/EMD/" style="font-size: 10px;">EMD</a> <a href="/tags/ERNIE/" style="font-size: 10px;">ERNIE</a> <a href="/tags/Economics/" style="font-size: 10px;">Economics</a> <a href="/tags/Edit-Distance/" style="font-size: 10px;">Edit Distance</a> <a href="/tags/Efficient-DeepLearning/" style="font-size: 10px;">Efficient-DeepLearning</a> <a href="/tags/Elasticsearch/" style="font-size: 10px;">Elasticsearch</a> <a href="/tags/Electra/" style="font-size: 10px;">Electra</a> <a href="/tags/Elixir/" style="font-size: 10.67px;">Elixir</a> <a href="/tags/Ellipsis/" style="font-size: 10px;">Ellipsis</a> <a href="/tags/Embedding/" style="font-size: 11.33px;">Embedding</a> <a href="/tags/Embeddings/" style="font-size: 10.67px;">Embeddings</a> <a href="/tags/Embodied-AI/" style="font-size: 10px;">Embodied AI</a> <a href="/tags/Encoder/" style="font-size: 10px;">Encoder</a> <a href="/tags/Entropy/" style="font-size: 11.33px;">Entropy</a> <a href="/tags/Evaluation/" style="font-size: 10.67px;">Evaluation</a> <a href="/tags/ExT5/" style="font-size: 10px;">ExT5</a> <a href="/tags/Exam/" style="font-size: 10px;">Exam</a> <a href="/tags/F1/" style="font-size: 10px;">F1</a> <a href="/tags/FDW/" style="font-size: 10px;">FDW</a> <a href="/tags/FLAN/" style="font-size: 10px;">FLAN</a> <a href="/tags/FSM/" style="font-size: 10px;">FSM</a> <a href="/tags/Faith/" style="font-size: 10px;">Faith</a> <a href="/tags/FastCuRL/" style="font-size: 10px;">FastCuRL</a> <a href="/tags/Feature-Engineering/" style="font-size: 10px;">Feature Engineering</a> <a href="/tags/Feature-based/" style="font-size: 10px;">Feature-based</a> <a href="/tags/Few-Shot/" style="font-size: 11.33px;">Few-Shot</a> <a href="/tags/Few-shot-Prompting/" style="font-size: 10px;">Few-shot Prompting</a> <a href="/tags/Fine-tuning/" style="font-size: 10px;">Fine-tuning</a> <a href="/tags/Formal-Grammars/" style="font-size: 11.33px;">Formal Grammars</a> <a href="/tags/Forward/" style="font-size: 10px;">Forward</a> <a href="/tags/Full-Text-Search/" style="font-size: 10px;">Full-Text-Search</a> <a href="/tags/Function-Syntax/" style="font-size: 10px;">Function Syntax</a> <a href="/tags/Funk-MF/" style="font-size: 10px;">Funk MF</a> <a href="/tags/Funnel-Transformer/" style="font-size: 10px;">Funnel Transformer</a> <a href="/tags/GAE/" style="font-size: 10px;">GAE</a> <a href="/tags/GBTD/" style="font-size: 10px;">GBTD</a> <a href="/tags/GELU/" style="font-size: 10px;">GELU</a> <a href="/tags/GP/" style="font-size: 10px;">GP</a> <a href="/tags/GPT-1/" style="font-size: 10px;">GPT-1</a> <a href="/tags/GPT-2/" style="font-size: 10.67px;">GPT-2</a> <a href="/tags/GPT-3/" style="font-size: 10px;">GPT-3</a> <a href="/tags/GPT3/" style="font-size: 10px;">GPT3</a> <a href="/tags/GPU/" style="font-size: 10px;">GPU</a> <a href="/tags/GRM/" style="font-size: 10px;">GRM</a> <a href="/tags/GRPO/" style="font-size: 13.33px;">GRPO</a> <a href="/tags/GRU/" style="font-size: 10px;">GRU</a> <a href="/tags/GSG/" style="font-size: 10px;">GSG</a> <a href="/tags/Gan/" style="font-size: 10px;">Gan</a> <a href="/tags/Garden-path/" style="font-size: 10px;">Garden-path</a> <a href="/tags/GiGPO/" style="font-size: 10px;">GiGPO</a> <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/Global-Pointer/" style="font-size: 10px;">Global Pointer</a> <a href="/tags/Glow/" style="font-size: 10px;">Glow</a> <a href="/tags/Graceful-Shutdown/" style="font-size: 10px;">Graceful Shutdown</a> <a href="/tags/Gradient-Descent/" style="font-size: 10px;">Gradient Descent</a> <a href="/tags/Graph/" style="font-size: 10.67px;">Graph</a> <a href="/tags/GraphQL/" style="font-size: 10.67px;">GraphQL</a> <a href="/tags/Grid-Grammar/" style="font-size: 10px;">Grid Grammar</a> <a href="/tags/Growth/" style="font-size: 12.67px;">Growth</a> <a href="/tags/H2O-Danube/" style="font-size: 10px;">H2O-Danube</a> <a href="/tags/HMM/" style="font-size: 10.67px;">HMM</a> <a href="/tags/Hard-SVM/" style="font-size: 10px;">Hard-SVM</a> <a href="/tags/Hinge-Loss/" style="font-size: 10px;">Hinge Loss</a> <a href="/tags/Hope/" style="font-size: 10px;">Hope</a> <a href="/tags/Host-only/" style="font-size: 10px;">Host-only</a> <a href="/tags/HuggingLLM/" style="font-size: 10px;">HuggingLLM</a> <a href="/tags/Human-in-Loop/" style="font-size: 10px;">Human-in-Loop</a> <a href="/tags/Human-in-the-Loop/" style="font-size: 10px;">Human-in-the-Loop</a> <a href="/tags/IDE/" style="font-size: 10px;">IDE</a> <a href="/tags/IE/" style="font-size: 10px;">IE</a> <a href="/tags/IQR/" style="font-size: 10px;">IQR</a> <a href="/tags/Imbalance-Data/" style="font-size: 10px;">Imbalance Data</a> <a href="/tags/Impossible-Triangle/" style="font-size: 10px;">Impossible-Triangle</a> <a href="/tags/In-Context-Learning/" style="font-size: 10.67px;">In-Context Learning</a> <a href="/tags/Industry/" style="font-size: 10px;">Industry</a> <a href="/tags/Inference-Scaling/" style="font-size: 11.33px;">Inference Scaling</a> <a href="/tags/Information-Extraction/" style="font-size: 10px;">Information Extraction</a> <a href="/tags/Information-Theory/" style="font-size: 10px;">Information Theory</a> <a href="/tags/Instruct/" style="font-size: 10px;">Instruct</a> <a href="/tags/InstructGPT/" style="font-size: 10.67px;">InstructGPT</a> <a href="/tags/Instruction-Following/" style="font-size: 12px;">Instruction Following</a> <a href="/tags/Instruction-Inference/" style="font-size: 10px;">Instruction Inference</a> <a href="/tags/Isolation-Forest/" style="font-size: 10px;">Isolation Forest</a> <a href="/tags/ItemCF/" style="font-size: 10px;">ItemCF</a> <a href="/tags/Jaccard/" style="font-size: 10px;">Jaccard</a> <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Jax/" style="font-size: 10px;">Jax</a> <a href="/tags/Job/" style="font-size: 10px;">Job</a> <a href="/tags/Jupyter/" style="font-size: 10px;">Jupyter</a> <a href="/tags/K2/" style="font-size: 10px;">K2</a> <a href="/tags/KKT/" style="font-size: 10px;">KKT</a> <a href="/tags/KL/" style="font-size: 10px;">KL</a> <a href="/tags/KS/" style="font-size: 10px;">KS</a> <a href="/tags/Kernel/" style="font-size: 10px;">Kernel</a> <a href="/tags/Kernel-Function/" style="font-size: 10px;">Kernel Function</a> <a href="/tags/Kernel-Method/" style="font-size: 10px;">Kernel Method</a> <a href="/tags/Keyword/" style="font-size: 10px;">Keyword</a> <a href="/tags/Knowledge-Graph/" style="font-size: 10.67px;">Knowledge Graph</a> <a href="/tags/L1/" style="font-size: 10px;">L1</a> <a href="/tags/LCPO/" style="font-size: 10px;">LCPO</a> <a href="/tags/LIMD/" style="font-size: 10.67px;">LIMD</a> <a href="/tags/LIMO/" style="font-size: 11.33px;">LIMO</a> <a href="/tags/LIMR/" style="font-size: 10.67px;">LIMR</a> <a href="/tags/LLM/" style="font-size: 18.67px;">LLM</a> <a href="/tags/LLM-Colosseum/" style="font-size: 10px;">LLM-Colosseum</a> <a href="/tags/LM/" style="font-size: 12px;">LM</a> <a href="/tags/LOF/" style="font-size: 10px;">LOF</a> <a href="/tags/LR/" style="font-size: 10px;">LR</a> <a href="/tags/LSTM/" style="font-size: 10px;">LSTM</a> <a href="/tags/Labeling/" style="font-size: 10px;">Labeling</a> <a href="/tags/Language-Model/" style="font-size: 10.67px;">Language Model</a> <a href="/tags/Lexical-Semantics/" style="font-size: 10px;">Lexical Semantics</a> <a href="/tags/Lexicalism/" style="font-size: 10px;">Lexicalism</a> <a href="/tags/Lexicalized-CFG/" style="font-size: 10px;">Lexicalized CFG</a> <a href="/tags/Lexicalized-Grammars/" style="font-size: 10px;">Lexicalized Grammars</a> <a href="/tags/Life/" style="font-size: 12px;">Life</a> <a href="/tags/Linear-Algebra/" style="font-size: 10px;">Linear Algebra</a> <a href="/tags/Linear-Sturcture/" style="font-size: 10px;">Linear Sturcture</a> <a href="/tags/Linked-List/" style="font-size: 10px;">Linked List</a> <a href="/tags/LinkedList/" style="font-size: 10.67px;">LinkedList</a> <a href="/tags/Linux/" style="font-size: 10px;">Linux</a> <a href="/tags/Llama/" style="font-size: 10px;">Llama</a> <a href="/tags/Logistic-Regression/" style="font-size: 10px;">Logistic Regression</a> <a href="/tags/Lucene/" style="font-size: 10px;">Lucene</a> <a href="/tags/Luong-Attention/" style="font-size: 10px;">Luong Attention</a> <a href="/tags/MEMM/" style="font-size: 10px;">MEMM</a> <a href="/tags/MF/" style="font-size: 10px;">MF</a> <a href="/tags/MIO/" style="font-size: 10px;">MIO</a> <a href="/tags/MM-Fusion/" style="font-size: 10px;">MM Fusion</a> <a href="/tags/MTL/" style="font-size: 11.33px;">MTL</a> <a href="/tags/Machine/" style="font-size: 10px;">Machine</a> <a href="/tags/Machine-Learning/" style="font-size: 14px;">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 10px;">Machine Translation</a> <a href="/tags/Manacher/" style="font-size: 10px;">Manacher</a> <a href="/tags/Managemnt/" style="font-size: 11.33px;">Managemnt</a> <a href="/tags/MarkBERT/" style="font-size: 10px;">MarkBERT</a> <a href="/tags/Markov/" style="font-size: 10px;">Markov</a> <a href="/tags/Materialized-Views/" style="font-size: 10px;">Materialized Views</a> <a href="/tags/Math/" style="font-size: 10.67px;">Math</a> <a href="/tags/Matplotlib/" style="font-size: 10px;">Matplotlib</a> <a href="/tags/Matrix-Factorization/" style="font-size: 10px;">Matrix Factorization</a> <a href="/tags/Median/" style="font-size: 10px;">Median</a> <a href="/tags/Meta-Learning/" style="font-size: 10px;">Meta Learning</a> <a href="/tags/Metric/" style="font-size: 10px;">Metric</a> <a href="/tags/Minimum-Edit-Distance/" style="font-size: 10px;">Minimum Edit Distance</a> <a href="/tags/Minkowski/" style="font-size: 10px;">Minkowski</a> <a href="/tags/Model-Evaluation/" style="font-size: 10px;">Model Evaluation</a> <a href="/tags/Module/" style="font-size: 10px;">Module</a> <a href="/tags/Multi-Head-Attention/" style="font-size: 10px;">Multi-Head Attention</a> <a href="/tags/Multi-Modal/" style="font-size: 10px;">Multi-Modal</a> <a href="/tags/MultiModal/" style="font-size: 10px;">MultiModal</a> <a href="/tags/Multitask/" style="font-size: 10px;">Multitask</a> <a href="/tags/Multiway-Tree/" style="font-size: 10px;">Multiway Tree</a> <a href="/tags/NAT/" style="font-size: 10px;">NAT</a> <a href="/tags/NER/" style="font-size: 14px;">NER</a> <a href="/tags/NLG/" style="font-size: 11.33px;">NLG</a> <a href="/tags/NLM/" style="font-size: 10.67px;">NLM</a> <a href="/tags/NLP/" style="font-size: 20px;">NLP</a> <a href="/tags/NLU/" style="font-size: 10px;">NLU</a> <a href="/tags/NMT/" style="font-size: 10px;">NMT</a> <a href="/tags/NNW/" style="font-size: 11.33px;">NNW</a> <a href="/tags/NTP/" style="font-size: 10px;">NTP</a> <a href="/tags/Naive-Bayes/" style="font-size: 10px;">Naive Bayes</a> <a href="/tags/Neo4j/" style="font-size: 10px;">Neo4j</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Ngram/" style="font-size: 10.67px;">Ngram</a> <a href="/tags/NodeJS/" style="font-size: 10px;">NodeJS</a> <a href="/tags/Normalizing-Flow/" style="font-size: 10px;">Normalizing Flow</a> <a href="/tags/NumPy/" style="font-size: 10px;">NumPy</a> <a href="/tags/Numba/" style="font-size: 10px;">Numba</a> <a href="/tags/Numpy/" style="font-size: 10px;">Numpy</a> <a href="/tags/OMNI/" style="font-size: 11.33px;">OMNI</a> <a href="/tags/ORZ/" style="font-size: 10px;">ORZ</a> <a href="/tags/Occupation/" style="font-size: 10px;">Occupation</a> <a href="/tags/One-Shot/" style="font-size: 10.67px;">One-Shot</a> <a href="/tags/Online-DPO-R1/" style="font-size: 10.67px;">Online-DPO-R1</a> <a href="/tags/OpenSource/" style="font-size: 10px;">OpenSource</a> <a href="/tags/Orientation/" style="font-size: 10px;">Orientation</a> <a href="/tags/P-R/" style="font-size: 10px;">P-R</a> <a href="/tags/PCCG/" style="font-size: 10px;">PCCG</a> <a href="/tags/PCFG/" style="font-size: 10px;">PCFG</a> <a href="/tags/PEGASUS/" style="font-size: 10px;">PEGASUS</a> <a href="/tags/PLM/" style="font-size: 10.67px;">PLM</a> <a href="/tags/PPMI/" style="font-size: 10px;">PPMI</a> <a href="/tags/PTM/" style="font-size: 10px;">PTM</a> <a href="/tags/PageRank/" style="font-size: 10px;">PageRank</a> <a href="/tags/Palindromic/" style="font-size: 10px;">Palindromic</a> <a href="/tags/Pandarallel/" style="font-size: 10px;">Pandarallel</a> <a href="/tags/Pandas/" style="font-size: 10.67px;">Pandas</a> <a href="/tags/Partial-Parsing/" style="font-size: 10px;">Partial Parsing</a> <a href="/tags/Passion/" style="font-size: 10px;">Passion</a> <a href="/tags/Pearson/" style="font-size: 10px;">Pearson</a> <a href="/tags/Philosophy/" style="font-size: 10.67px;">Philosophy</a> <a href="/tags/Phrase-Structure-Grammar/" style="font-size: 10px;">Phrase Structure Grammar</a> <a href="/tags/Phrase-Structure-Grammars/" style="font-size: 10px;">Phrase Structure Grammars</a> <a href="/tags/PoS/" style="font-size: 10px;">PoS</a> <a href="/tags/Polars/" style="font-size: 10px;">Polars</a> <a href="/tags/Pooling/" style="font-size: 10px;">Pooling</a> <a href="/tags/Position-Encoding/" style="font-size: 10px;">Position-Encoding</a> <a href="/tags/Post-training/" style="font-size: 16px;">Post-training</a> <a href="/tags/Postgres/" style="font-size: 10.67px;">Postgres</a> <a href="/tags/Pragmatic-Automatic-Processing/" style="font-size: 10px;">Pragmatic Automatic Processing</a> <a href="/tags/Pre-Trained/" style="font-size: 10px;">Pre-Trained</a> <a href="/tags/Pre-Training/" style="font-size: 10px;">Pre-Training</a> <a href="/tags/Pre-training/" style="font-size: 14.67px;">Pre-training</a> <a href="/tags/Precision/" style="font-size: 10px;">Precision</a> <a href="/tags/Pretrain/" style="font-size: 10.67px;">Pretrain</a> <a href="/tags/Pretrained/" style="font-size: 10px;">Pretrained</a> <a href="/tags/Pretraining/" style="font-size: 10.67px;">Pretraining</a> <a href="/tags/Probabilistic-Grammar/" style="font-size: 10px;">Probabilistic Grammar</a> <a href="/tags/Probabilistic-Model/" style="font-size: 10px;">Probabilistic Model</a> <a href="/tags/Promote/" style="font-size: 10px;">Promote</a> <a href="/tags/Prompt/" style="font-size: 12.67px;">Prompt</a> <a href="/tags/ProtoBERT/" style="font-size: 10px;">ProtoBERT</a> <a href="/tags/Pruning/" style="font-size: 10px;">Pruning</a> <a href="/tags/Psychology/" style="font-size: 10.67px;">Psychology</a> <a href="/tags/PyPI/" style="font-size: 10px;">PyPI</a> <a href="/tags/Python/" style="font-size: 18px;">Python</a> <a href="/tags/QA/" style="font-size: 10px;">QA</a> <a href="/tags/Quant/" style="font-size: 10px;">Quant</a> <a href="/tags/Quantization/" style="font-size: 10px;">Quantization</a> <a href="/tags/Query/" style="font-size: 10px;">Query</a> <a href="/tags/Queue/" style="font-size: 10px;">Queue</a> <a href="/tags/Qwen3/" style="font-size: 10px;">Qwen3</a> <a href="/tags/R-Drop/" style="font-size: 10.67px;">R-Drop</a> <a href="/tags/R1/" style="font-size: 11.33px;">R1</a> <a href="/tags/R1-Zero/" style="font-size: 13.33px;">R1-Zero</a> <a href="/tags/RAG/" style="font-size: 10px;">RAG</a> <a href="/tags/RELU/" style="font-size: 10px;">RELU</a> <a href="/tags/RFE/" style="font-size: 10px;">RFE</a> <a href="/tags/RHO/" style="font-size: 10px;">RHO</a> <a href="/tags/RHO-1/" style="font-size: 10px;">RHO-1</a> <a href="/tags/RL/" style="font-size: 13.33px;">RL</a> <a href="/tags/RLHF/" style="font-size: 10px;">RLHF</a> <a href="/tags/RM/" style="font-size: 10.67px;">RM</a> <a href="/tags/RM-R1/" style="font-size: 10px;">RM-R1</a> <a href="/tags/RMSE/" style="font-size: 10px;">RMSE</a> <a href="/tags/RNN/" style="font-size: 10px;">RNN</a> <a href="/tags/ROC/" style="font-size: 10px;">ROC</a> <a href="/tags/RWD/" style="font-size: 10px;">RWD</a> <a href="/tags/Rank/" style="font-size: 10px;">Rank</a> <a href="/tags/RaspberryPi/" style="font-size: 10.67px;">RaspberryPi</a> <a href="/tags/Raspberrypi/" style="font-size: 10px;">Raspberrypi</a> <a href="/tags/Recall/" style="font-size: 10px;">Recall</a> <a href="/tags/Recommendation/" style="font-size: 12.67px;">Recommendation</a> <a href="/tags/Recursion/" style="font-size: 10.67px;">Recursion</a> <a href="/tags/Reformer/" style="font-size: 10px;">Reformer</a> <a href="/tags/Regex/" style="font-size: 10px;">Regex</a> <a href="/tags/Regular-Expression/" style="font-size: 10px;">Regular Expression</a> <a href="/tags/Reinforcement-Learning/" style="font-size: 10px;">Reinforcement Learning</a> <a href="/tags/Relationship-Extraction/" style="font-size: 10px;">Relationship Extraction</a> <a href="/tags/Representation/" style="font-size: 10.67px;">Representation</a> <a href="/tags/Reqular-Expressions/" style="font-size: 10px;">Reqular Expressions</a> <a href="/tags/Retrieving/" style="font-size: 10px;">Retrieving</a> <a href="/tags/Reward/" style="font-size: 10px;">Reward</a> <a href="/tags/RoBERTa/" style="font-size: 10px;">RoBERTa</a> <a href="/tags/Rotated-Sorted-Array/" style="font-size: 10px;">Rotated Sorted Array</a> <a href="/tags/Rust/" style="font-size: 16px;">Rust</a> <a href="/tags/SCFG/" style="font-size: 10px;">SCFG</a> <a href="/tags/SGD/" style="font-size: 10px;">SGD</a> <a href="/tags/SLM/" style="font-size: 10.67px;">SLM</a> <a href="/tags/SMO/" style="font-size: 10px;">SMO</a> <a href="/tags/SQL/" style="font-size: 10.67px;">SQL</a> <a href="/tags/SRN/" style="font-size: 10px;">SRN</a> <a href="/tags/STaR/" style="font-size: 10px;">STaR</a> <a href="/tags/SVD/" style="font-size: 10px;">SVD++</a> <a href="/tags/SVM/" style="font-size: 10.67px;">SVM</a> <a href="/tags/Scaling/" style="font-size: 10px;">Scaling</a> <a href="/tags/Scaling-Law/" style="font-size: 10px;">Scaling Law</a> <a href="/tags/Seaborn/" style="font-size: 10px;">Seaborn</a> <a href="/tags/Search/" style="font-size: 10.67px;">Search</a> <a href="/tags/Seed-Thinking/" style="font-size: 10px;">Seed-Thinking</a> <a href="/tags/Segmentation/" style="font-size: 10px;">Segmentation</a> <a href="/tags/Selection-Inference/" style="font-size: 10px;">Selection-Inference</a> <a href="/tags/Self-Attention/" style="font-size: 11.33px;">Self-Attention</a> <a href="/tags/Semantic-Automatic-Processing/" style="font-size: 10px;">Semantic Automatic Processing</a> <a href="/tags/Semantic-Similarity/" style="font-size: 10px;">Semantic Similarity</a> <a href="/tags/Senta/" style="font-size: 10px;">Senta</a> <a href="/tags/Sentence-Representation/" style="font-size: 10px;">Sentence Representation</a> <a href="/tags/Sentence-Similarity/" style="font-size: 10px;">Sentence Similarity</a> <a href="/tags/Sentence-BERT/" style="font-size: 10px;">Sentence-BERT</a> <a href="/tags/Sentiment-Classification/" style="font-size: 10px;">Sentiment Classification</a> <a href="/tags/SentimentAnalysis/" style="font-size: 10px;">SentimentAnalysis</a> <a href="/tags/Siamese/" style="font-size: 10px;">Siamese</a> <a href="/tags/Sigmoid/" style="font-size: 10px;">Sigmoid</a> <a href="/tags/SimCSE/" style="font-size: 10.67px;">SimCSE</a> <a href="/tags/Similarity/" style="font-size: 10px;">Similarity</a> <a href="/tags/Simon/" style="font-size: 10px;">Simon</a> <a href="/tags/Simple-Zoo/" style="font-size: 10px;">Simple-Zoo</a> <a href="/tags/Simpson-Paradox/" style="font-size: 10px;">Simpson Paradox</a> <a href="/tags/Skill/" style="font-size: 10px;">Skill</a> <a href="/tags/Skywork-Reward/" style="font-size: 10px;">Skywork Reward</a> <a href="/tags/Slide/" style="font-size: 10px;">Slide</a> <a href="/tags/Smoothing/" style="font-size: 10.67px;">Smoothing</a> <a href="/tags/Soft-SVM/" style="font-size: 10px;">Soft-SVM</a> <a href="/tags/Softmax/" style="font-size: 10px;">Softmax</a> <a href="/tags/Sort/" style="font-size: 10.67px;">Sort</a> <a href="/tags/Span/" style="font-size: 11.33px;">Span</a> <a href="/tags/Spell-Check/" style="font-size: 10px;">Spell Check</a> <a href="/tags/Spurious-Reward/" style="font-size: 10px;">Spurious Reward</a> <a href="/tags/SqueezeBERT/" style="font-size: 10px;">SqueezeBERT</a> <a href="/tags/Stable-LM/" style="font-size: 10px;">Stable LM</a> <a href="/tags/Stack/" style="font-size: 10px;">Stack</a> <a href="/tags/Stacking/" style="font-size: 10px;">Stacking</a> <a href="/tags/Statistics/" style="font-size: 10px;">Statistics</a> <a href="/tags/Stirling/" style="font-size: 10px;">Stirling</a> <a href="/tags/Strategic/" style="font-size: 10px;">Strategic</a> <a href="/tags/StratifiedKFold/" style="font-size: 10px;">StratifiedKFold</a> <a href="/tags/String/" style="font-size: 10.67px;">String</a> <a href="/tags/Style/" style="font-size: 10px;">Style</a> <a href="/tags/Substring/" style="font-size: 10px;">Substring</a> <a href="/tags/Summarization/" style="font-size: 10.67px;">Summarization</a> <a href="/tags/Supertagging/" style="font-size: 10px;">Supertagging</a> <a href="/tags/Swap/" style="font-size: 10px;">Swap</a> <a href="/tags/System/" style="font-size: 10.67px;">System</a> <a href="/tags/T5/" style="font-size: 10.67px;">T5</a> <a href="/tags/TF-IDF/" style="font-size: 10px;">TF-IDF</a> <a href="/tags/THW/" style="font-size: 11.33px;">THW</a> <a href="/tags/TS3-Codec/" style="font-size: 10px;">TS3-Codec</a> <a href="/tags/TTRL/" style="font-size: 10px;">TTRL</a> <a href="/tags/TTS/" style="font-size: 14px;">TTS</a> <a href="/tags/Tagging/" style="font-size: 10px;">Tagging</a> <a href="/tags/TanH/" style="font-size: 10px;">TanH</a> <a href="/tags/TensorBay/" style="font-size: 10px;">TensorBay</a> <a href="/tags/Tensorflow/" style="font-size: 10px;">Tensorflow</a> <a href="/tags/Test/" style="font-size: 10px;">Test</a> <a href="/tags/Text-Classification/" style="font-size: 10px;">Text Classification</a> <a href="/tags/Text-Generation/" style="font-size: 10px;">Text Generation</a> <a href="/tags/Text-Normalization/" style="font-size: 10px;">Text Normalization</a> <a href="/tags/TextCNN/" style="font-size: 10.67px;">TextCNN</a> <a href="/tags/TextRank/" style="font-size: 10px;">TextRank</a> <a href="/tags/Thought/" style="font-size: 10.67px;">Thought</a> <a href="/tags/Transformer/" style="font-size: 17.33px;">Transformer</a> <a href="/tags/Transformer-XL/" style="font-size: 10px;">Transformer-XL</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a> <a href="/tags/Treebank/" style="font-size: 10px;">Treebank</a> <a href="/tags/Tuning/" style="font-size: 10px;">Tuning</a> <a href="/tags/Tutorial/" style="font-size: 10px;">Tutorial</a> <a href="/tags/Ubuntu/" style="font-size: 10px;">Ubuntu</a> <a href="/tags/UniLM/" style="font-size: 10px;">UniLM</a> <a href="/tags/Unity-Operation/" style="font-size: 10px;">Unity Operation</a> <a href="/tags/Unix/" style="font-size: 10px;">Unix</a> <a href="/tags/Unsupervised-Elicitation/" style="font-size: 10px;">Unsupervised Elicitation</a> <a href="/tags/UserCF/" style="font-size: 10px;">UserCF</a> <a href="/tags/VAPO/" style="font-size: 10px;">VAPO</a> <a href="/tags/VITS/" style="font-size: 10px;">VITS</a> <a href="/tags/Vagrant/" style="font-size: 10px;">Vagrant</a> <a href="/tags/Valence/" style="font-size: 10px;">Valence</a> <a href="/tags/Vector-Semantics/" style="font-size: 10px;">Vector Semantics</a> <a href="/tags/Verifier/" style="font-size: 10px;">Verifier</a> <a href="/tags/Virtual-Network/" style="font-size: 10px;">Virtual Network</a> <a href="/tags/VirtualBox/" style="font-size: 10px;">VirtualBox</a> <a href="/tags/Visualization/" style="font-size: 10px;">Visualization</a> <a href="/tags/Viterbi/" style="font-size: 10.67px;">Viterbi</a> <a href="/tags/Vocabulary-Learning/" style="font-size: 10px;">Vocabulary Learning</a> <a href="/tags/VoiceAgent/" style="font-size: 10px;">VoiceAgent</a> <a href="/tags/Voila/" style="font-size: 10px;">Voila</a> <a href="/tags/Voting/" style="font-size: 10px;">Voting</a> <a href="/tags/W2NER/" style="font-size: 11.33px;">W2NER</a> <a href="/tags/WOE/" style="font-size: 10px;">WOE</a> <a href="/tags/Web-Server-Multithreaded-Server/" style="font-size: 10px;">Web Server Multithreaded Server</a> <a href="/tags/Wide/" style="font-size: 10px;">Wide</a> <a href="/tags/Word2vec/" style="font-size: 10px;">Word2vec</a> <a href="/tags/Work/" style="font-size: 10px;">Work</a> <a href="/tags/XLNet/" style="font-size: 10px;">XLNet</a> <a href="/tags/XTTS/" style="font-size: 10px;">XTTS</a> <a href="/tags/Z-Score/" style="font-size: 10px;">Z-Score</a> <a href="/tags/Zero-Short/" style="font-size: 10px;">Zero-Short</a> <a href="/tags/Zero-Shot/" style="font-size: 11.33px;">Zero-Shot</a> <a href="/tags/Zero-shot/" style="font-size: 10px;">Zero-shot</a> <a href="/tags/ZhouZhihua/" style="font-size: 10px;">ZhouZhihua</a> <a href="/tags/Zipf/" style="font-size: 10px;">Zipf</a> <a href="/tags/Ziya/" style="font-size: 10.67px;">Ziya</a> <a href="/tags/binning/" style="font-size: 10px;">binning</a> <a href="/tags/emacs/" style="font-size: 10px;">emacs</a> <a href="/tags/few-shot/" style="font-size: 10px;">few-shot</a> <a href="/tags/ffmpeg/" style="font-size: 10px;">ffmpeg</a> <a href="/tags/jpype/" style="font-size: 10px;">jpype</a> <a href="/tags/knowledge-Graph/" style="font-size: 10px;">knowledge Graph</a> <a href="/tags/motion/" style="font-size: 10px;">motion</a> <a href="/tags/node2vec/" style="font-size: 10px;">node2vec</a> <a href="/tags/oat-zero/" style="font-size: 10.67px;">oat-zero</a> <a href="/tags/orz/" style="font-size: 10px;">orz</a> <a href="/tags/s1/" style="font-size: 11.33px;">s1</a> <a href="/tags/ssh/" style="font-size: 10px;">ssh</a> <a href="/tags/str/" style="font-size: 10px;">str</a> <a href="/tags/vim/" style="font-size: 10px;">vim</a> <a href="/tags/vlc/" style="font-size: 10px;">vlc</a>
    </div>
  </aside>

  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2025 hscspring
    All rights reserved.</p>
    <p>Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></p>
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <!-- <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span> -->
    <!-- <span id="busuanzi_container_page_pv">本文总阅读量<span id="busuanzi_value_page_pv"></span>次</span> -->
    <!-- <span id="busuanzi_container_site_uv">本站访客数<span id="busuanzi_value_site_uv"></span>人次</span> -->

</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>